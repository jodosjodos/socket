'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import { ValidationError } from './errorHandler';
class DomainClient {
    /**
   * Returns domain client token
   * @returns {String} client token
   */ get token() {
        return this._token;
    }
    /**
   * Sends a MetaStats API request
   * @param {Function} getOpts function to get request options
   * @param {String} accountId account id
   * @returns {Object|String|any} request result
   */ requestMetastats(getOpts, accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._updateHost();
            yield _this._updateAccountHost(accountId);
            const accountCache = _this._accountCache[accountId];
            try {
                const regionSettings = accountCache.regions[accountCache.regionIndex];
                const opts = getOpts(`https://metastats-api-v1.${regionSettings.region}.${_this._urlCache.domain}`, regionSettings.id);
                return yield _this._httpClient.request(opts);
            } catch (err) {
                if (![
                    'ConflictError',
                    'InternalError',
                    'ApiError',
                    'TimeoutError'
                ].includes(err.name)) {
                    throw err;
                } else {
                    if (accountCache.regions.length === accountCache.regionIndex + 1) {
                        accountCache.regionIndex = 0;
                        throw err;
                    } else {
                        accountCache.regionIndex++;
                        return yield _this.requestMetastats(getOpts, accountId);
                    }
                }
            }
        })();
    }
    _updateHost() {
        var _this = this;
        return _async_to_generator(function*() {
            if (!_this._urlCache || _this._urlCache.lastUpdated < Date.now() - 1000 * 60 * 10) {
                const urlSettings = yield _this._httpClient.requestWithFailover({
                    url: `https://mt-provisioning-api-v1.${_this._domain}/users/current/servers/mt-client-api`,
                    method: 'GET',
                    headers: {
                        'auth-token': _this._token
                    },
                    json: true
                });
                _this._urlCache = {
                    domain: urlSettings.domain,
                    lastUpdated: Date.now()
                };
            }
        })();
    }
    _updateAccountHost(accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            if (!_this._accountCache[accountId] || _this._accountCache[accountId].lastUpdated < Date.now() - 1000 * 60 * 10) {
                const getAccount = function() {
                    var _ref = _async_to_generator(function*(id) {
                        const accountOpts = {
                            url: `https://mt-provisioning-api-v1.${_this._domain}/users/current/accounts/${id}`,
                            method: 'GET',
                            headers: {
                                'auth-token': _this._token
                            },
                            json: true
                        };
                        return yield _this._httpClient.requestWithFailover(accountOpts);
                    });
                    return function getAccount(id) {
                        return _ref.apply(this, arguments);
                    };
                }();
                let accounts = [];
                let accountData = yield getAccount(accountId);
                if (accountData.primaryAccountId) {
                    accountData = yield getAccount(accountData.primaryAccountId);
                }
                accounts = [
                    {
                        _id: accountData._id,
                        region: accountData.region,
                        state: accountData.state
                    }
                ].concat(accountData.accountReplicas || []);
                accounts = accounts.filter((account)=>account.state === 'DEPLOYED');
                if (!accounts.length) {
                    throw new ValidationError('There are no replicas deployed yet. Please make sure at least ' + 'one of the replicas is deployed.');
                }
                let regions = accounts.map((account)=>({
                        region: account.region,
                        id: account._id
                    }));
                _this._accountCache[accountId] = {
                    regions,
                    regionIndex: 0,
                    lastUpdated: Date.now()
                };
            }
        })();
    }
    /**
   * Constructs domain client instance
   * @param {HttpClient} httpClient HTTP client
   * @param {String} token authorization token
   * @param {String} domain domain to connect to, default is agiliumtrade.agiliumtrade.ai
   */ constructor(httpClient, token, domain = 'agiliumtrade.agiliumtrade.ai'){
        this._httpClient = httpClient;
        this._domain = domain;
        this._token = token;
        this._urlCache = null;
        this._accountCache = {};
    }
}
/**
 * Connection URL and request managing client
 */ export { DomainClient as default };
