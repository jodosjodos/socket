"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return MetaApiConnectionInstance;
    }
});
const _metaApiWebsocketclient = /*#__PURE__*/ _interop_require_default(require("../clients/metaApi/metaApiWebsocket.client"));
const _logger = /*#__PURE__*/ _interop_require_default(require("../logger"));
const _randomstring = /*#__PURE__*/ _interop_require_default(require("randomstring"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let MetaApiConnectionInstance = class MetaApiConnectionInstance {
    /**
   * Opens the connection. Can only be called the first time, next calls will be ignored.
   * @return {Promise} promise resolving when the connection is opened
   */ async connect() {
        this._opened = true;
    }
    /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   */ async close() {
        this._opened = false;
        this._closed = true;
    }
    /**
   * Common trade options
   * @typedef {Object} TradeOptions
   * @property {String} [comment] optional order comment. The sum of the line lengths of the comment and the
   * clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [clientId] optional client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {Number} [magic] optional magic (expert id) number. If not set default value specified in account entity
   * will be used.
   * @property {Number} [slippage] optional slippage in points. Should be greater or equal to zero. In not set,
   * default value specified in account entity will be used. Slippage is ignored if execution mode set to
   * SYMBOL_TRADE_EXECUTION_MARKET in symbol specification. Not used for close by orders.
   */ /**
   * Market trade options
   * @typedef {TradeOptions} MarketTradeOptions
   * @property {Array<String>} [fillingModes] optional allowed filling modes in the order of priority. Default is to
   * allow all filling modes and prefer ORDER_FILLING_FOK over ORDER_FILLING_IOC. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_filling for extra
   * explanation
   */ /**
   * Market trade options
   * @typedef {MarketTradeOptions} CreateMarketTradeOptions
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {String} [stopPriceBase] defines the base price to calculate SL/TP relative to for pending order
   * requests. Default is CURRENT_PRICE, one of CURRENT_PRICE
   */ /**
   * Pending order trade options
   * @typedef {TradeOptions} PendingTradeOptions
   * @property {ExpirationOptions} [expiration] optional pending order expiration settings. See Pending order expiration
   * settings section
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {String} [stopPriceBase] defined the base price to calculate SL/TP relative to for *_MODIFY and pending
   * order requests. STOP_PRICE means the SL/TP is relative to previous SL/TP value. Default is OPEN_PRICE, one of
   * CURRENT_PRICE, OPEN_PRICE
   * @property {String} [openPriceUnits] open price units. ABSOLUTE_PRICE means the that the value of openPrice field
   * is a final open price value. RELATIVE* means that the openPrice field value contains relative open price expressed
   * either in price, points, pips, account currency or balance percentage. Default is ABSOLUTE_PRICE. One of
   * ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   */ /**
   * Options for creating a stop limit pending order
   * @typedef {PendingTradeOptions} StopLimitPendingTradeOptions
   * @property {String} [openPriceBase] defined the base price to calculate open price relative to for ORDER_MODIFY
   * and pending order requests. Default is CURRENT_PRICE for pending orders or STOP_LIMIT_PRICE for stop limit orders.
   * One of CURRENT_PRICE, OPEN_PRICE, STOP_LIMIT_PRICE
   * @property {String} [stopLimitPriceUnits] stop limit price units. ABSOLUTE_PRICE means the that the value of
   * stopLimitPrice field is a final stop limit price value. RELATIVE* means that the stopLimitPrice field value
   * contains relative stop limit price expressed either in price, points, pips, account currency or balance percentage.
   * Default is ABSOLUTE_PRICE. One of ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY,
   * RELATIVE_BALANCE_PERCENTAGE
   */ /**
   * Options for modifying orders
   * @typedef {Object} ModifyOrderOptions
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {String} [stopPriceBase] defined the base price to calculate SL/TP relative to for *_MODIFY and pending
   * order requests. STOP_PRICE means the SL/TP is relative to previous SL/TP value. Default is OPEN_PRICE, one of
   * CURRENT_PRICE, OPEN_PRICE, STOP_PRICE
   * @property {String} [openPriceUnits] open price units. ABSOLUTE_PRICE means the that the value of openPrice field
   * is a final open price value. RELATIVE* means that the openPrice field value contains relative open price expressed
   * either in price, points, pips, account currency or balance percentage. Default is ABSOLUTE_PRICE. One of
   * ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   * @property {String} [openPriceBase] defined the base price to calculate open price relative to for ORDER_MODIFY
   * and pending order requests. Default is CURRENT_PRICE for pending orders or STOP_LIMIT_PRICE for stop limit orders.
   * One of CURRENT_PRICE, OPEN_PRICE, STOP_LIMIT_PRICE
   * @property {String} [stopLimitPriceUnits] stop limit price units. ABSOLUTE_PRICE means the that the value of
   * stopLimitPrice field is a final stop limit price value. RELATIVE* means that the stopLimitPrice field value
   * contains relative stop limit price expressed either in price, points, pips, account currency or balance percentage.
   * Default is ABSOLUTE_PRICE. One of ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY,
   * RELATIVE_BALANCE_PERCENTAGE
   * @property {String} [stopLimitPriceBase] Defined the base price to calculate stop limit price relative to for
   * ORDER_MODIFY requests. One of CURRENT_PRICE, STOP_LIMIT_PRICE
   */ /**
   * Pending order expiration settings
   * @typedef {Object} ExpirationOptions
   * @property {String} type pending order expiration type. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_time for the list of
   * possible options. MetaTrader4 platform supports only ORDER_TIME_SPECIFIED expiration type. One of ORDER_TIME_GTC,
   * ORDER_TIME_DAY, ORDER_TIME_SPECIFIED, ORDER_TIME_SPECIFIED_DAY
   * @property {Date} [time] optional pending order expiration time. Ignored if expiration type is not one of
   * ORDER_TIME_DAY or ORDER_TIME_SPECIFIED
   */ /**
   * Stop options
   * @typedef {Object} StopOptions
   * @property {number} value stop (SL or TP) value
   * @property {string} units stop units. ABSOLUTE_PRICE means the that the value of value field is a final stop value.
   * RELATIVE_* means that the value field value contains relative stop expressed either in price, points, pips, account
   * currency or balance percentage. Default is ABSOLUTE_PRICE. Allowed values are ABSOLUTE_PRICE, RELATIVE_PRICE,
   * RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   */ /**
   * Creates a market buy order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {CreateMarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createMarketBuyOrder(symbol, volume, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_BUY",
            symbol,
            volume
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a market sell order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {CreateMarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createMarketSellOrder(symbol, volume, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_SELL",
            symbol,
            volume
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a limit buy order
   * @param {String} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order limit price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createLimitBuyOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_BUY_LIMIT",
            symbol,
            volume,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a limit sell order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order limit price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createLimitSellOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_SELL_LIMIT",
            symbol,
            volume,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a stop buy order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createStopBuyOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_BUY_STOP",
            symbol,
            volume,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a stop sell order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createStopSellOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_SELL_STOP",
            symbol,
            volume,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a stop limit buy order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number} stopLimitPrice the limit order price for the stop limit order
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {StopLimitPendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createStopLimitBuyOrder(symbol, volume, openPrice, stopLimitPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_BUY_STOP_LIMIT",
            symbol,
            volume,
            openPrice,
            stopLimitPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a stop limit sell order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number} stopLimitPrice the limit order price for the stop limit order
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {StopLimitPendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createStopLimitSellOrder(symbol, volume, openPrice, stopLimitPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_SELL_STOP_LIMIT",
            symbol,
            volume,
            openPrice,
            stopLimitPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Modifies a position
   * @param {string} positionId position id to modify
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {TrailingStopLoss} trailingStopLoss distance trailing stop loss configuration
   * @param {String} [stopPriceBase] defines the base price to calculate SL relative to for POSITION_MODIFY and
   * pending order requests. Default is OPEN_PRICE. One of CURRENT_PRICE, OPEN_PRICE, STOP_PRICE
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ modifyPosition(positionId, stopLoss, takeProfit, trailingStopLoss, stopPriceBase) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "POSITION_MODIFY",
            positionId,
            trailingStopLoss,
            stopPriceBase
        }, this._generateStopOptions(stopLoss, takeProfit)));
    }
    /**
   * Partially closes a position
   * @param {string} positionId position id to modify
   * @param {number} volume volume to close
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ closePositionPartially(positionId, volume, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "POSITION_PARTIAL",
            positionId,
            volume
        }, options || {}));
    }
    /**
   * Fully closes a position
   * @param {string} positionId position id to modify
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ closePosition(positionId, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "POSITION_CLOSE_ID",
            positionId
        }, options || {}));
    }
    /**
   * Fully closes a position
   * @param {string} positionId position id to close by opposite position
   * @param {string} oppositePositionId opposite position id to close
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ closeBy(positionId, oppositePositionId, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "POSITION_CLOSE_BY",
            positionId,
            closeByPositionId: oppositePositionId
        }, options || {}));
    }
    /**
   * Closes positions by a symbol
   * @param {string} symbol symbol to trade
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ closePositionsBySymbol(symbol, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "POSITIONS_CLOSE_SYMBOL",
            symbol
        }, options || {}));
    }
    /**
   * Modifies a pending order
   * @param {string} orderId order id (ticket number)
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {ModifyOrderOptions} [options] optional modify order options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ modifyOrder(orderId, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_MODIFY",
            orderId,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Cancels order
   * @param {string} orderId order id (ticket number)
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ cancelOrder(orderId) {
        this._checkIsConnectionActive();
        return this._trade({
            actionType: "ORDER_CANCEL",
            orderId
        });
    }
    _trade(request) {
        return this._websocketClient.trade(this._metaApiConnection.account.id, request, this._metaApiConnection.application, this._metaApiConnection.account.reliability);
    }
    /**
   * Calculates margin required to open a trade on the specified trading account
   * @param {MarginOrder} order order to calculate margin for
   * @returns {Promise<Margin>} promise resolving with margin calculation result
   */ calculateMargin(order) {
        this._checkIsConnectionActive();
        return this._websocketClient.calculateMargin(this._metaApiConnection.account.id, this._metaApiConnection.application, this._metaApiConnection.account.reliability, order);
    }
    /**
   * Forces refresh and retrieves latest quotes for a subset of symbols the terminal is subscribed to. Note, that this
   * method works separately from the streamed data (for streaming connection), so the response may be obsolete already,
   * if some updates happen during the request
   * @param {string[]} symbols quote symbols to refresh
   * @returns {Promise<RefreshedQuotes>} quotes that was actually updated (a subset of specified symbols), and some of
   * basic account information
   */ refreshSymbolQuotes(symbols) {
        this._checkIsConnectionActive();
        return this._websocketClient.refreshSymbolQuotes(this._metaApiConnection.account.id, symbols);
    }
    /**
   * Returns MetaApi account
   * @return {MetatraderAccount} MetaApi account
   */ get account() {
        return this._metaApiConnection.account;
    }
    /**
   * Returns connection instance id
   * @return {String} connection instance id
   */ get instanceId() {
        return this._instanceId;
    }
    _generateStopOptions(stopLoss, takeProfit) {
        let trade = {};
        if (typeof stopLoss === "number") {
            trade.stopLoss = stopLoss;
        } else if (stopLoss) {
            trade.stopLoss = stopLoss.value;
            trade.stopLossUnits = stopLoss.units;
        }
        if (typeof takeProfit === "number") {
            trade.takeProfit = takeProfit;
        } else if (takeProfit) {
            trade.takeProfit = takeProfit.value;
            trade.takeProfitUnits = takeProfit.units;
        }
        return trade;
    }
    _checkIsConnectionActive() {
        if (!this._opened) {
            throw new Error("This connection has not been initialized yet, please invoke await connection.connect()");
        }
        if (this._closed) {
            throw new Error("This connection has been closed, please create a new connection");
        }
    }
    /**
   * Constructs MetaApi MetaTrader Api connection instance
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {MetaApiConnection} metaApiConnection MetaApi connection to use
   */ constructor(websocketClient, metaApiConnection){
        this._websocketClient = websocketClient;
        this._metaApiConnection = metaApiConnection;
        this._instanceId = _randomstring.default.generate(32);
        this._logger = _logger.default.getLogger("MetaApiConnectionInstance");
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBNZXRhQXBpV2Vic29ja2V0Q2xpZW50IGZyb20gJy4uL2NsaWVudHMvbWV0YUFwaS9tZXRhQXBpV2Vic29ja2V0LmNsaWVudCc7XG5pbXBvcnQgTG9nZ2VyTWFuYWdlciBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHJhbmRvbXN0cmluZyBmcm9tICdyYW5kb21zdHJpbmcnO1xuXG4vKipcbiAqIEV4cG9zZXMgTWV0YUFwaSBNZXRhVHJhZGVyIEFQSSBjb25uZWN0aW9uIGluc3RhbmNlIHRvIGNvbnN1bWVyc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBNZXRhQXBpIE1ldGFUcmFkZXIgQXBpIGNvbm5lY3Rpb24gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50fSB3ZWJzb2NrZXRDbGllbnQgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50XG4gICAqIEBwYXJhbSB7TWV0YUFwaUNvbm5lY3Rpb259IG1ldGFBcGlDb25uZWN0aW9uIE1ldGFBcGkgY29ubmVjdGlvbiB0byB1c2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdlYnNvY2tldENsaWVudCwgbWV0YUFwaUNvbm5lY3Rpb24pIHtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQgPSB3ZWJzb2NrZXRDbGllbnQ7XG4gICAgdGhpcy5fbWV0YUFwaUNvbm5lY3Rpb24gPSBtZXRhQXBpQ29ubmVjdGlvbjtcbiAgICB0aGlzLl9pbnN0YW5jZUlkID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXJNYW5hZ2VyLmdldExvZ2dlcignTWV0YUFwaUNvbm5lY3Rpb25JbnN0YW5jZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBjb25uZWN0aW9uLiBDYW4gb25seSBiZSBjYWxsZWQgdGhlIGZpcnN0IHRpbWUsIG5leHQgY2FsbHMgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5lZFxuICAgKi9cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICB0aGlzLl9vcGVuZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi4gVGhlIGluc3RhbmNlIG9mIHRoZSBjbGFzcyBzaG91bGQgbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXIgdGhpcyBtZXRob2QgaXMgaW52b2tlZC5cbiAgICovXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHRoaXMuX29wZW5lZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDb21tb24gdHJhZGUgb3B0aW9uc1xuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUcmFkZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtjb21tZW50XSBvcHRpb25hbCBvcmRlciBjb21tZW50LiBUaGUgc3VtIG9mIHRoZSBsaW5lIGxlbmd0aHMgb2YgdGhlIGNvbW1lbnQgYW5kIHRoZVxuICAgKiBjbGllbnRJZCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyNi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9jbGllbnRJZFVzYWdlL1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NsaWVudElkXSBvcHRpb25hbCBjbGllbnQtYXNzaWduZWQgaWQuIFRoZSBpZCB2YWx1ZSBjYW4gYmUgYXNzaWduZWQgd2hlbiBzdWJtaXR0aW5nIGEgdHJhZGUgYW5kXG4gICAqIHdpbGwgYmUgcHJlc2VudCBvbiBwb3NpdGlvbiwgaGlzdG9yeSBvcmRlcnMgYW5kIGhpc3RvcnkgZGVhbHMgcmVsYXRlZCB0byB0aGUgdHJhZGUuIFlvdSBjYW4gdXNlIHRoaXMgZmllbGQgdG8gYmluZFxuICAgKiB5b3VyIHRyYWRlcyB0byBvYmplY3RzIGluIHlvdXIgYXBwbGljYXRpb24gYW5kIHRoZW4gdHJhY2sgdHJhZGUgcHJvZ3Jlc3MuIFRoZSBzdW0gb2YgdGhlIGxpbmUgbGVuZ3RocyBvZiB0aGVcbiAgICogY29tbWVudCBhbmQgdGhlIGNsaWVudElkIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDI2LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L2NsaWVudElkVXNhZ2UvXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWFnaWNdIG9wdGlvbmFsIG1hZ2ljIChleHBlcnQgaWQpIG51bWJlci4gSWYgbm90IHNldCBkZWZhdWx0IHZhbHVlIHNwZWNpZmllZCBpbiBhY2NvdW50IGVudGl0eVxuICAgKiB3aWxsIGJlIHVzZWQuXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc2xpcHBhZ2VdIG9wdGlvbmFsIHNsaXBwYWdlIGluIHBvaW50cy4gU2hvdWxkIGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gemVyby4gSW4gbm90IHNldCxcbiAgICogZGVmYXVsdCB2YWx1ZSBzcGVjaWZpZWQgaW4gYWNjb3VudCBlbnRpdHkgd2lsbCBiZSB1c2VkLiBTbGlwcGFnZSBpcyBpZ25vcmVkIGlmIGV4ZWN1dGlvbiBtb2RlIHNldCB0b1xuICAgKiBTWU1CT0xfVFJBREVfRVhFQ1VUSU9OX01BUktFVCBpbiBzeW1ib2wgc3BlY2lmaWNhdGlvbi4gTm90IHVzZWQgZm9yIGNsb3NlIGJ5IG9yZGVycy5cbiAgICovXG5cbiAgLyoqXG4gICAqIE1hcmtldCB0cmFkZSBvcHRpb25zXG4gICAqIEB0eXBlZGVmIHtUcmFkZU9wdGlvbnN9IE1hcmtldFRyYWRlT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge0FycmF5PFN0cmluZz59IFtmaWxsaW5nTW9kZXNdIG9wdGlvbmFsIGFsbG93ZWQgZmlsbGluZyBtb2RlcyBpbiB0aGUgb3JkZXIgb2YgcHJpb3JpdHkuIERlZmF1bHQgaXMgdG9cbiAgICogYWxsb3cgYWxsIGZpbGxpbmcgbW9kZXMgYW5kIHByZWZlciBPUkRFUl9GSUxMSU5HX0ZPSyBvdmVyIE9SREVSX0ZJTExJTkdfSU9DLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9vcmRlcnByb3BlcnRpZXMjZW51bV9vcmRlcl90eXBlX2ZpbGxpbmcgZm9yIGV4dHJhXG4gICAqIGV4cGxhbmF0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNYXJrZXQgdHJhZGUgb3B0aW9uc1xuICAgKiBAdHlwZWRlZiB7TWFya2V0VHJhZGVPcHRpb25zfSBDcmVhdGVNYXJrZXRUcmFkZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtUcmFpbGluZ1N0b3BMb3NzfSBbdHJhaWxpbmdTdG9wTG9zc10gZGlzdGFuY2UgdHJhaWxpbmcgc3RvcCBsb3NzIGNvbmZpZ3VyYXRpb25cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzdG9wUHJpY2VCYXNlXSBkZWZpbmVzIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBTTC9UUCByZWxhdGl2ZSB0byBmb3IgcGVuZGluZyBvcmRlclxuICAgKiByZXF1ZXN0cy4gRGVmYXVsdCBpcyBDVVJSRU5UX1BSSUNFLCBvbmUgb2YgQ1VSUkVOVF9QUklDRVxuICAgKi9cblxuICAvKipcbiAgICogUGVuZGluZyBvcmRlciB0cmFkZSBvcHRpb25zXG4gICAqIEB0eXBlZGVmIHtUcmFkZU9wdGlvbnN9IFBlbmRpbmdUcmFkZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtFeHBpcmF0aW9uT3B0aW9uc30gW2V4cGlyYXRpb25dIG9wdGlvbmFsIHBlbmRpbmcgb3JkZXIgZXhwaXJhdGlvbiBzZXR0aW5ncy4gU2VlIFBlbmRpbmcgb3JkZXIgZXhwaXJhdGlvblxuICAgKiBzZXR0aW5ncyBzZWN0aW9uXG4gICAqIEBwcm9wZXJ0eSB7VHJhaWxpbmdTdG9wTG9zc30gW3RyYWlsaW5nU3RvcExvc3NdIGRpc3RhbmNlIHRyYWlsaW5nIHN0b3AgbG9zcyBjb25maWd1cmF0aW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcFByaWNlQmFzZV0gZGVmaW5lZCB0aGUgYmFzZSBwcmljZSB0byBjYWxjdWxhdGUgU0wvVFAgcmVsYXRpdmUgdG8gZm9yICpfTU9ESUZZIGFuZCBwZW5kaW5nXG4gICAqIG9yZGVyIHJlcXVlc3RzLiBTVE9QX1BSSUNFIG1lYW5zIHRoZSBTTC9UUCBpcyByZWxhdGl2ZSB0byBwcmV2aW91cyBTTC9UUCB2YWx1ZS4gRGVmYXVsdCBpcyBPUEVOX1BSSUNFLCBvbmUgb2ZcbiAgICogQ1VSUkVOVF9QUklDRSwgT1BFTl9QUklDRVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW29wZW5QcmljZVVuaXRzXSBvcGVuIHByaWNlIHVuaXRzLiBBQlNPTFVURV9QUklDRSBtZWFucyB0aGUgdGhhdCB0aGUgdmFsdWUgb2Ygb3BlblByaWNlIGZpZWxkXG4gICAqIGlzIGEgZmluYWwgb3BlbiBwcmljZSB2YWx1ZS4gUkVMQVRJVkUqIG1lYW5zIHRoYXQgdGhlIG9wZW5QcmljZSBmaWVsZCB2YWx1ZSBjb250YWlucyByZWxhdGl2ZSBvcGVuIHByaWNlIGV4cHJlc3NlZFxuICAgKiBlaXRoZXIgaW4gcHJpY2UsIHBvaW50cywgcGlwcywgYWNjb3VudCBjdXJyZW5jeSBvciBiYWxhbmNlIHBlcmNlbnRhZ2UuIERlZmF1bHQgaXMgQUJTT0xVVEVfUFJJQ0UuIE9uZSBvZlxuICAgKiBBQlNPTFVURV9QUklDRSwgUkVMQVRJVkVfUFJJQ0UsIFJFTEFUSVZFX1BPSU5UUywgUkVMQVRJVkVfUElQUywgUkVMQVRJVkVfQ1VSUkVOQ1ksIFJFTEFUSVZFX0JBTEFOQ0VfUEVSQ0VOVEFHRVxuICAgKi9cblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgY3JlYXRpbmcgYSBzdG9wIGxpbWl0IHBlbmRpbmcgb3JkZXJcbiAgICogQHR5cGVkZWYge1BlbmRpbmdUcmFkZU9wdGlvbnN9IFN0b3BMaW1pdFBlbmRpbmdUcmFkZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtvcGVuUHJpY2VCYXNlXSBkZWZpbmVkIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBvcGVuIHByaWNlIHJlbGF0aXZlIHRvIGZvciBPUkRFUl9NT0RJRllcbiAgICogYW5kIHBlbmRpbmcgb3JkZXIgcmVxdWVzdHMuIERlZmF1bHQgaXMgQ1VSUkVOVF9QUklDRSBmb3IgcGVuZGluZyBvcmRlcnMgb3IgU1RPUF9MSU1JVF9QUklDRSBmb3Igc3RvcCBsaW1pdCBvcmRlcnMuXG4gICAqIE9uZSBvZiBDVVJSRU5UX1BSSUNFLCBPUEVOX1BSSUNFLCBTVE9QX0xJTUlUX1BSSUNFXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcExpbWl0UHJpY2VVbml0c10gc3RvcCBsaW1pdCBwcmljZSB1bml0cy4gQUJTT0xVVEVfUFJJQ0UgbWVhbnMgdGhlIHRoYXQgdGhlIHZhbHVlIG9mXG4gICAqIHN0b3BMaW1pdFByaWNlIGZpZWxkIGlzIGEgZmluYWwgc3RvcCBsaW1pdCBwcmljZSB2YWx1ZS4gUkVMQVRJVkUqIG1lYW5zIHRoYXQgdGhlIHN0b3BMaW1pdFByaWNlIGZpZWxkIHZhbHVlXG4gICAqIGNvbnRhaW5zIHJlbGF0aXZlIHN0b3AgbGltaXQgcHJpY2UgZXhwcmVzc2VkIGVpdGhlciBpbiBwcmljZSwgcG9pbnRzLCBwaXBzLCBhY2NvdW50IGN1cnJlbmN5IG9yIGJhbGFuY2UgcGVyY2VudGFnZS5cbiAgICogRGVmYXVsdCBpcyBBQlNPTFVURV9QUklDRS4gT25lIG9mIEFCU09MVVRFX1BSSUNFLCBSRUxBVElWRV9QUklDRSwgUkVMQVRJVkVfUE9JTlRTLCBSRUxBVElWRV9QSVBTLCBSRUxBVElWRV9DVVJSRU5DWSxcbiAgICogUkVMQVRJVkVfQkFMQU5DRV9QRVJDRU5UQUdFXG4gICAqL1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBtb2RpZnlpbmcgb3JkZXJzXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1vZGlmeU9yZGVyT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge1RyYWlsaW5nU3RvcExvc3N9IFt0cmFpbGluZ1N0b3BMb3NzXSBkaXN0YW5jZSB0cmFpbGluZyBzdG9wIGxvc3MgY29uZmlndXJhdGlvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3N0b3BQcmljZUJhc2VdIGRlZmluZWQgdGhlIGJhc2UgcHJpY2UgdG8gY2FsY3VsYXRlIFNML1RQIHJlbGF0aXZlIHRvIGZvciAqX01PRElGWSBhbmQgcGVuZGluZ1xuICAgKiBvcmRlciByZXF1ZXN0cy4gU1RPUF9QUklDRSBtZWFucyB0aGUgU0wvVFAgaXMgcmVsYXRpdmUgdG8gcHJldmlvdXMgU0wvVFAgdmFsdWUuIERlZmF1bHQgaXMgT1BFTl9QUklDRSwgb25lIG9mXG4gICAqIENVUlJFTlRfUFJJQ0UsIE9QRU5fUFJJQ0UsIFNUT1BfUFJJQ0VcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtvcGVuUHJpY2VVbml0c10gb3BlbiBwcmljZSB1bml0cy4gQUJTT0xVVEVfUFJJQ0UgbWVhbnMgdGhlIHRoYXQgdGhlIHZhbHVlIG9mIG9wZW5QcmljZSBmaWVsZFxuICAgKiBpcyBhIGZpbmFsIG9wZW4gcHJpY2UgdmFsdWUuIFJFTEFUSVZFKiBtZWFucyB0aGF0IHRoZSBvcGVuUHJpY2UgZmllbGQgdmFsdWUgY29udGFpbnMgcmVsYXRpdmUgb3BlbiBwcmljZSBleHByZXNzZWRcbiAgICogZWl0aGVyIGluIHByaWNlLCBwb2ludHMsIHBpcHMsIGFjY291bnQgY3VycmVuY3kgb3IgYmFsYW5jZSBwZXJjZW50YWdlLiBEZWZhdWx0IGlzIEFCU09MVVRFX1BSSUNFLiBPbmUgb2ZcbiAgICogQUJTT0xVVEVfUFJJQ0UsIFJFTEFUSVZFX1BSSUNFLCBSRUxBVElWRV9QT0lOVFMsIFJFTEFUSVZFX1BJUFMsIFJFTEFUSVZFX0NVUlJFTkNZLCBSRUxBVElWRV9CQUxBTkNFX1BFUkNFTlRBR0VcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtvcGVuUHJpY2VCYXNlXSBkZWZpbmVkIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBvcGVuIHByaWNlIHJlbGF0aXZlIHRvIGZvciBPUkRFUl9NT0RJRllcbiAgICogYW5kIHBlbmRpbmcgb3JkZXIgcmVxdWVzdHMuIERlZmF1bHQgaXMgQ1VSUkVOVF9QUklDRSBmb3IgcGVuZGluZyBvcmRlcnMgb3IgU1RPUF9MSU1JVF9QUklDRSBmb3Igc3RvcCBsaW1pdCBvcmRlcnMuXG4gICAqIE9uZSBvZiBDVVJSRU5UX1BSSUNFLCBPUEVOX1BSSUNFLCBTVE9QX0xJTUlUX1BSSUNFXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcExpbWl0UHJpY2VVbml0c10gc3RvcCBsaW1pdCBwcmljZSB1bml0cy4gQUJTT0xVVEVfUFJJQ0UgbWVhbnMgdGhlIHRoYXQgdGhlIHZhbHVlIG9mXG4gICAqIHN0b3BMaW1pdFByaWNlIGZpZWxkIGlzIGEgZmluYWwgc3RvcCBsaW1pdCBwcmljZSB2YWx1ZS4gUkVMQVRJVkUqIG1lYW5zIHRoYXQgdGhlIHN0b3BMaW1pdFByaWNlIGZpZWxkIHZhbHVlXG4gICAqIGNvbnRhaW5zIHJlbGF0aXZlIHN0b3AgbGltaXQgcHJpY2UgZXhwcmVzc2VkIGVpdGhlciBpbiBwcmljZSwgcG9pbnRzLCBwaXBzLCBhY2NvdW50IGN1cnJlbmN5IG9yIGJhbGFuY2UgcGVyY2VudGFnZS5cbiAgICogRGVmYXVsdCBpcyBBQlNPTFVURV9QUklDRS4gT25lIG9mIEFCU09MVVRFX1BSSUNFLCBSRUxBVElWRV9QUklDRSwgUkVMQVRJVkVfUE9JTlRTLCBSRUxBVElWRV9QSVBTLCBSRUxBVElWRV9DVVJSRU5DWSxcbiAgICogUkVMQVRJVkVfQkFMQU5DRV9QRVJDRU5UQUdFXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcExpbWl0UHJpY2VCYXNlXSBEZWZpbmVkIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBzdG9wIGxpbWl0IHByaWNlIHJlbGF0aXZlIHRvIGZvclxuICAgKiBPUkRFUl9NT0RJRlkgcmVxdWVzdHMuIE9uZSBvZiBDVVJSRU5UX1BSSUNFLCBTVE9QX0xJTUlUX1BSSUNFXG4gICAqL1xuXG4gIC8qKlxuICAgKiBQZW5kaW5nIG9yZGVyIGV4cGlyYXRpb24gc2V0dGluZ3NcbiAgICogQHR5cGVkZWYge09iamVjdH0gRXhwaXJhdGlvbk9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgcGVuZGluZyBvcmRlciBleHBpcmF0aW9uIHR5cGUuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL29yZGVycHJvcGVydGllcyNlbnVtX29yZGVyX3R5cGVfdGltZSBmb3IgdGhlIGxpc3Qgb2ZcbiAgICogcG9zc2libGUgb3B0aW9ucy4gTWV0YVRyYWRlcjQgcGxhdGZvcm0gc3VwcG9ydHMgb25seSBPUkRFUl9USU1FX1NQRUNJRklFRCBleHBpcmF0aW9uIHR5cGUuIE9uZSBvZiBPUkRFUl9USU1FX0dUQyxcbiAgICogT1JERVJfVElNRV9EQVksIE9SREVSX1RJTUVfU1BFQ0lGSUVELCBPUkRFUl9USU1FX1NQRUNJRklFRF9EQVlcbiAgICogQHByb3BlcnR5IHtEYXRlfSBbdGltZV0gb3B0aW9uYWwgcGVuZGluZyBvcmRlciBleHBpcmF0aW9uIHRpbWUuIElnbm9yZWQgaWYgZXhwaXJhdGlvbiB0eXBlIGlzIG5vdCBvbmUgb2ZcbiAgICogT1JERVJfVElNRV9EQVkgb3IgT1JERVJfVElNRV9TUEVDSUZJRURcbiAgICovXG5cbiAgLyoqXG4gICAqIFN0b3Agb3B0aW9uc1xuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTdG9wT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gdmFsdWUgc3RvcCAoU0wgb3IgVFApIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1bml0cyBzdG9wIHVuaXRzLiBBQlNPTFVURV9QUklDRSBtZWFucyB0aGUgdGhhdCB0aGUgdmFsdWUgb2YgdmFsdWUgZmllbGQgaXMgYSBmaW5hbCBzdG9wIHZhbHVlLlxuICAgKiBSRUxBVElWRV8qIG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZpZWxkIHZhbHVlIGNvbnRhaW5zIHJlbGF0aXZlIHN0b3AgZXhwcmVzc2VkIGVpdGhlciBpbiBwcmljZSwgcG9pbnRzLCBwaXBzLCBhY2NvdW50XG4gICAqIGN1cnJlbmN5IG9yIGJhbGFuY2UgcGVyY2VudGFnZS4gRGVmYXVsdCBpcyBBQlNPTFVURV9QUklDRS4gQWxsb3dlZCB2YWx1ZXMgYXJlIEFCU09MVVRFX1BSSUNFLCBSRUxBVElWRV9QUklDRSxcbiAgICogUkVMQVRJVkVfUE9JTlRTLCBSRUxBVElWRV9QSVBTLCBSRUxBVElWRV9DVVJSRU5DWSwgUkVMQVRJVkVfQkFMQU5DRV9QRVJDRU5UQUdFXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWFya2V0IGJ1eSBvcmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge0NyZWF0ZU1hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVNYXJrZXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX0JVWScsIHN5bWJvbCwgdm9sdW1lfSxcbiAgICAgIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1hcmtldCBzZWxsIG9yZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7Q3JlYXRlTWFya2V0VHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZU1hcmtldFNlbGxPcmRlcihzeW1ib2wsIHZvbHVtZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTEwnLCBzeW1ib2wsIHZvbHVtZX0sXG4gICAgICB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsaW1pdCBidXkgb3JkZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBsaW1pdCBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge1BlbmRpbmdUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY3JlYXRlTGltaXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfQlVZX0xJTUlUJywgc3ltYm9sLFxuICAgICAgdm9sdW1lLCBvcGVuUHJpY2V9LCB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsaW1pdCBzZWxsIG9yZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgbGltaXQgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZUxpbWl0U2VsbE9yZGVyKHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZShPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnT1JERVJfVFlQRV9TRUxMX0xJTUlUJywgc3ltYm9sLFxuICAgICAgdm9sdW1lLCBvcGVuUHJpY2V9LCB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdG9wIGJ1eSBvcmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BlblByaWNlIG9yZGVyIHN0b3AgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZVN0b3BCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfQlVZX1NUT1AnLCBzeW1ib2wsXG4gICAgICB2b2x1bWUsIG9wZW5QcmljZX0sIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0b3Agc2VsbCBvcmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BlblByaWNlIG9yZGVyIHN0b3AgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZVN0b3BTZWxsT3JkZXIoc3ltYm9sLCB2b2x1bWUsIG9wZW5QcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTExfU1RPUCcsIHN5bWJvbCxcbiAgICAgIHZvbHVtZSwgb3BlblByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3RvcCBsaW1pdCBidXkgb3JkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBzdG9wIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdG9wTGltaXRQcmljZSB0aGUgbGltaXQgb3JkZXIgcHJpY2UgZm9yIHRoZSBzdG9wIGxpbWl0IG9yZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7U3RvcExpbWl0UGVuZGluZ1RyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVTdG9wTGltaXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTGltaXRQcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX0JVWV9TVE9QX0xJTUlUJyxcbiAgICAgIHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMaW1pdFByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3RvcCBsaW1pdCBzZWxsIG9yZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgc3RvcCBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RvcExpbWl0UHJpY2UgdGhlIGxpbWl0IG9yZGVyIHByaWNlIGZvciB0aGUgc3RvcCBsaW1pdCBvcmRlclxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge1N0b3BMaW1pdFBlbmRpbmdUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY3JlYXRlU3RvcExpbWl0U2VsbE9yZGVyKHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMaW1pdFByaWNlLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfU0VMTF9TVE9QX0xJTUlUJyxcbiAgICAgIHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMaW1pdFByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkIHRvIG1vZGlmeVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge1RyYWlsaW5nU3RvcExvc3N9IHRyYWlsaW5nU3RvcExvc3MgZGlzdGFuY2UgdHJhaWxpbmcgc3RvcCBsb3NzIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzdG9wUHJpY2VCYXNlXSBkZWZpbmVzIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBTTCByZWxhdGl2ZSB0byBmb3IgUE9TSVRJT05fTU9ESUZZIGFuZFxuICAgKiBwZW5kaW5nIG9yZGVyIHJlcXVlc3RzLiBEZWZhdWx0IGlzIE9QRU5fUFJJQ0UuIE9uZSBvZiBDVVJSRU5UX1BSSUNFLCBPUEVOX1BSSUNFLCBTVE9QX1BSSUNFXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBtb2RpZnlQb3NpdGlvbihwb3NpdGlvbklkLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgdHJhaWxpbmdTdG9wTG9zcywgc3RvcFByaWNlQmFzZSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdQT1NJVElPTl9NT0RJRlknLCBwb3NpdGlvbklkLCB0cmFpbGluZ1N0b3BMb3NzLCBzdG9wUHJpY2VCYXNlfSxcbiAgICAgIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpKSk7XG4gIH1cblxuICAvKipcbiAgICogUGFydGlhbGx5IGNsb3NlcyBhIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkIHRvIG1vZGlmeVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIHZvbHVtZSB0byBjbG9zZVxuICAgKiBAcGFyYW0ge01hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjbG9zZVBvc2l0aW9uUGFydGlhbGx5KHBvc2l0aW9uSWQsIHZvbHVtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX1BBUlRJQUwnLCBwb3NpdGlvbklkLFxuICAgICAgdm9sdW1lfSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bGx5IGNsb3NlcyBhIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkIHRvIG1vZGlmeVxuICAgKiBAcGFyYW0ge01hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjbG9zZVBvc2l0aW9uKHBvc2l0aW9uSWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdQT1NJVElPTl9DTE9TRV9JRCcsIHBvc2l0aW9uSWR9LFxuICAgICAgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bGx5IGNsb3NlcyBhIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkIHRvIGNsb3NlIGJ5IG9wcG9zaXRlIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHBvc2l0ZVBvc2l0aW9uSWQgb3Bwb3NpdGUgcG9zaXRpb24gaWQgdG8gY2xvc2VcbiAgICogQHBhcmFtIHtNYXJrZXRUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY2xvc2VCeShwb3NpdGlvbklkLCBvcHBvc2l0ZVBvc2l0aW9uSWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdQT1NJVElPTl9DTE9TRV9CWScsIHBvc2l0aW9uSWQsXG4gICAgICBjbG9zZUJ5UG9zaXRpb25JZDogb3Bwb3NpdGVQb3NpdGlvbklkfSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyBwb3NpdGlvbnMgYnkgYSBzeW1ib2xcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtNYXJrZXRUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY2xvc2VQb3NpdGlvbnNCeVN5bWJvbChzeW1ib2wsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdQT1NJVElPTlNfQ0xPU0VfU1lNQk9MJywgc3ltYm9sfSxcbiAgICAgIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhIHBlbmRpbmcgb3JkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yZGVySWQgb3JkZXIgaWQgKHRpY2tldCBudW1iZXIpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgc3RvcCBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge01vZGlmeU9yZGVyT3B0aW9uc30gW29wdGlvbnNdIG9wdGlvbmFsIG1vZGlmeSBvcmRlciBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBtb2RpZnlPcmRlcihvcmRlcklkLCBvcGVuUHJpY2UsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZShPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnT1JERVJfTU9ESUZZJywgb3JkZXJJZCwgb3BlblByaWNlfSxcbiAgICAgIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBvcmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JkZXJJZCBvcmRlciBpZCAodGlja2V0IG51bWJlcilcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNhbmNlbE9yZGVyKG9yZGVySWQpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZSh7YWN0aW9uVHlwZTogJ09SREVSX0NBTkNFTCcsIG9yZGVySWR9KTtcbiAgfVxuXG4gIF90cmFkZShyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC50cmFkZSh0aGlzLl9tZXRhQXBpQ29ubmVjdGlvbi5hY2NvdW50LmlkLCByZXF1ZXN0LFxuICAgICAgdGhpcy5fbWV0YUFwaUNvbm5lY3Rpb24uYXBwbGljYXRpb24sIHRoaXMuX21ldGFBcGlDb25uZWN0aW9uLmFjY291bnQucmVsaWFiaWxpdHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgbWFyZ2luIHJlcXVpcmVkIHRvIG9wZW4gYSB0cmFkZSBvbiB0aGUgc3BlY2lmaWVkIHRyYWRpbmcgYWNjb3VudFxuICAgKiBAcGFyYW0ge01hcmdpbk9yZGVyfSBvcmRlciBvcmRlciB0byBjYWxjdWxhdGUgbWFyZ2luIGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNYXJnaW4+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIG1hcmdpbiBjYWxjdWxhdGlvbiByZXN1bHRcbiAgICovXG4gIGNhbGN1bGF0ZU1hcmdpbihvcmRlcikge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5jYWxjdWxhdGVNYXJnaW4odGhpcy5fbWV0YUFwaUNvbm5lY3Rpb24uYWNjb3VudC5pZCxcbiAgICAgIHRoaXMuX21ldGFBcGlDb25uZWN0aW9uLmFwcGxpY2F0aW9uLCB0aGlzLl9tZXRhQXBpQ29ubmVjdGlvbi5hY2NvdW50LnJlbGlhYmlsaXR5LCBvcmRlcik7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2VzIHJlZnJlc2ggYW5kIHJldHJpZXZlcyBsYXRlc3QgcXVvdGVzIGZvciBhIHN1YnNldCBvZiBzeW1ib2xzIHRoZSB0ZXJtaW5hbCBpcyBzdWJzY3JpYmVkIHRvLiBOb3RlLCB0aGF0IHRoaXNcbiAgICogbWV0aG9kIHdvcmtzIHNlcGFyYXRlbHkgZnJvbSB0aGUgc3RyZWFtZWQgZGF0YSAoZm9yIHN0cmVhbWluZyBjb25uZWN0aW9uKSwgc28gdGhlIHJlc3BvbnNlIG1heSBiZSBvYnNvbGV0ZSBhbHJlYWR5LFxuICAgKiBpZiBzb21lIHVwZGF0ZXMgaGFwcGVuIGR1cmluZyB0aGUgcmVxdWVzdFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBzeW1ib2xzIHF1b3RlIHN5bWJvbHMgdG8gcmVmcmVzaFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWZyZXNoZWRRdW90ZXM+fSBxdW90ZXMgdGhhdCB3YXMgYWN0dWFsbHkgdXBkYXRlZCAoYSBzdWJzZXQgb2Ygc3BlY2lmaWVkIHN5bWJvbHMpLCBhbmQgc29tZSBvZlxuICAgKiBiYXNpYyBhY2NvdW50IGluZm9ybWF0aW9uXG4gICAqL1xuICByZWZyZXNoU3ltYm9sUXVvdGVzKHN5bWJvbHMpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVmcmVzaFN5bWJvbFF1b3Rlcyh0aGlzLl9tZXRhQXBpQ29ubmVjdGlvbi5hY2NvdW50LmlkLCBzeW1ib2xzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE1ldGFBcGkgYWNjb3VudFxuICAgKiBAcmV0dXJuIHtNZXRhdHJhZGVyQWNjb3VudH0gTWV0YUFwaSBhY2NvdW50XG4gICAqL1xuICBnZXQgYWNjb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWV0YUFwaUNvbm5lY3Rpb24uYWNjb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvbm5lY3Rpb24gaW5zdGFuY2UgaWRcbiAgICogQHJldHVybiB7U3RyaW5nfSBjb25uZWN0aW9uIGluc3RhbmNlIGlkXG4gICAqL1xuICBnZXQgaW5zdGFuY2VJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2VJZDtcbiAgfVxuXG4gIF9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSB7XG4gICAgbGV0IHRyYWRlID0ge307XG4gICAgaWYgKHR5cGVvZiBzdG9wTG9zcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRyYWRlLnN0b3BMb3NzID0gc3RvcExvc3M7XG4gICAgfSBlbHNlIGlmIChzdG9wTG9zcykge1xuICAgICAgdHJhZGUuc3RvcExvc3MgPSBzdG9wTG9zcy52YWx1ZTtcbiAgICAgIHRyYWRlLnN0b3BMb3NzVW5pdHMgPSBzdG9wTG9zcy51bml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0YWtlUHJvZml0ID09PSAnbnVtYmVyJykge1xuICAgICAgdHJhZGUudGFrZVByb2ZpdCA9IHRha2VQcm9maXQ7XG4gICAgfSBlbHNlIGlmICh0YWtlUHJvZml0KSB7XG4gICAgICB0cmFkZS50YWtlUHJvZml0ID0gdGFrZVByb2ZpdC52YWx1ZTtcbiAgICAgIHRyYWRlLnRha2VQcm9maXRVbml0cyA9IHRha2VQcm9maXQudW5pdHM7XG4gICAgfVxuICAgIHJldHVybiB0cmFkZTtcbiAgfVxuXG4gIF9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpIHtcbiAgICBpZighdGhpcy5fb3BlbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LCBwbGVhc2UgaW52b2tlIGF3YWl0IGNvbm5lY3Rpb24uY29ubmVjdCgpJyk7XG4gICAgfVxuICAgIGlmKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkLCBwbGVhc2UgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24nKTtcbiAgICB9XG4gIH1cblxufVxuIl0sIm5hbWVzIjpbIk1ldGFBcGlDb25uZWN0aW9uSW5zdGFuY2UiLCJjb25uZWN0IiwiX29wZW5lZCIsImNsb3NlIiwiX2Nsb3NlZCIsImNyZWF0ZU1hcmtldEJ1eU9yZGVyIiwic3ltYm9sIiwidm9sdW1lIiwic3RvcExvc3MiLCJ0YWtlUHJvZml0Iiwib3B0aW9ucyIsIl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSIsIl90cmFkZSIsIk9iamVjdCIsImFzc2lnbiIsImFjdGlvblR5cGUiLCJfZ2VuZXJhdGVTdG9wT3B0aW9ucyIsImNyZWF0ZU1hcmtldFNlbGxPcmRlciIsImNyZWF0ZUxpbWl0QnV5T3JkZXIiLCJvcGVuUHJpY2UiLCJjcmVhdGVMaW1pdFNlbGxPcmRlciIsImNyZWF0ZVN0b3BCdXlPcmRlciIsImNyZWF0ZVN0b3BTZWxsT3JkZXIiLCJjcmVhdGVTdG9wTGltaXRCdXlPcmRlciIsInN0b3BMaW1pdFByaWNlIiwiY3JlYXRlU3RvcExpbWl0U2VsbE9yZGVyIiwibW9kaWZ5UG9zaXRpb24iLCJwb3NpdGlvbklkIiwidHJhaWxpbmdTdG9wTG9zcyIsInN0b3BQcmljZUJhc2UiLCJjbG9zZVBvc2l0aW9uUGFydGlhbGx5IiwiY2xvc2VQb3NpdGlvbiIsImNsb3NlQnkiLCJvcHBvc2l0ZVBvc2l0aW9uSWQiLCJjbG9zZUJ5UG9zaXRpb25JZCIsImNsb3NlUG9zaXRpb25zQnlTeW1ib2wiLCJtb2RpZnlPcmRlciIsIm9yZGVySWQiLCJjYW5jZWxPcmRlciIsInJlcXVlc3QiLCJfd2Vic29ja2V0Q2xpZW50IiwidHJhZGUiLCJfbWV0YUFwaUNvbm5lY3Rpb24iLCJhY2NvdW50IiwiaWQiLCJhcHBsaWNhdGlvbiIsInJlbGlhYmlsaXR5IiwiY2FsY3VsYXRlTWFyZ2luIiwib3JkZXIiLCJyZWZyZXNoU3ltYm9sUXVvdGVzIiwic3ltYm9scyIsImluc3RhbmNlSWQiLCJfaW5zdGFuY2VJZCIsInZhbHVlIiwic3RvcExvc3NVbml0cyIsInVuaXRzIiwidGFrZVByb2ZpdFVuaXRzIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIndlYnNvY2tldENsaWVudCIsIm1ldGFBcGlDb25uZWN0aW9uIiwicmFuZG9tc3RyaW5nIiwiZ2VuZXJhdGUiLCJfbG9nZ2VyIiwiTG9nZ2VyTWFuYWdlciIsImdldExvZ2dlciJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7ZUFTcUJBOzs7K0VBUGM7K0RBQ1Q7cUVBQ0Q7Ozs7OztBQUtWLElBQUEsQUFBTUEsNEJBQU4sTUFBTUE7SUFjbkI7OztHQUdDLEdBQ0QsTUFBTUMsVUFBVTtRQUNkLElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBQ2pCO0lBRUE7O0dBRUMsR0FDRCxNQUFNQyxRQUFRO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNFLE9BQU8sR0FBRztJQUNqQjtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JDLEdBRUQ7Ozs7Ozs7R0FPQyxHQUVEOzs7Ozs7R0FNQyxHQUVEOzs7Ozs7Ozs7Ozs7O0dBYUMsR0FFRDs7Ozs7Ozs7Ozs7R0FXQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxQkMsR0FFRDs7Ozs7Ozs7O0dBU0MsR0FFRDs7Ozs7Ozs7R0FRQyxHQUVEOzs7Ozs7Ozs7R0FTQyxHQUNEQyxxQkFBcUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRTtRQUN2RSxJQUFJLENBQUNDLHdCQUF3QjtRQUM3QixPQUFPLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxPQUFPQyxNQUFNLENBQUM7WUFBQ0MsWUFBWTtZQUFrQlQ7WUFBUUM7UUFBTSxHQUM1RSxJQUFJLENBQUNTLG9CQUFvQixDQUFDUixVQUFVQyxhQUFhQyxXQUFXLENBQUM7SUFDakU7SUFFQTs7Ozs7Ozs7O0dBU0MsR0FDRE8sc0JBQXNCWCxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxVQUFVLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDeEUsSUFBSSxDQUFDQyx3QkFBd0I7UUFDN0IsT0FBTyxJQUFJLENBQUNDLE1BQU0sQ0FBQ0Ms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