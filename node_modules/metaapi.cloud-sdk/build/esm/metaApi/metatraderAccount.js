'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import TimeoutError from '../clients/timeoutError';
import RpcMetaApiConnectionInstance from './rpcMetaApiConnectionInstance';
import StreamingMetaApiConnectionInstance from './streamingMetaApiConnectionInstance';
import HistoryDatabase from './historyDatabase/index';
import ExpertAdvisor from './expertAdvisor';
import { ValidationError } from '../clients/errorHandler';
import MetatraderAccountReplica from './metatraderAccountReplica';
//eslint-disable-next-line max-len
import { Reliability, State, Version, ConnectionStatus, CopyFactoryRoles, Type, AccountConnection, ConfigurationLink } from '../clients/metaApi/metatraderAccount.client';
let MetatraderAccount = class MetatraderAccount {
    /**
   * Returns unique account id
   * @return {string} unique account id
   */ get id() {
        return this._data._id;
    }
    /**
   * Returns current account state. One of CREATED, DEPLOYING, DEPLOYED, DEPLOY_FAILED, UNDEPLOYING,
   * UNDEPLOYED, UNDEPLOY_FAILED, DELETING, DELETE_FAILED, REDEPLOY_FAILED, DRAFT
   * @return {State} current account state
   */ get state() {
        return this._data.state;
    }
    /**
   * Returns MetaTrader magic to place trades using
   * @return {number} MetaTrader magic to place trades using
   */ get magic() {
        return this._data.magic;
    }
    /**
   * Returns terminal & broker connection status, one of CONNECTED, DISCONNECTED, DISCONNECTED_FROM_BROKER
   * @return {ConnectionStatus} terminal & broker connection status
   */ get connectionStatus() {
        return this._data.connectionStatus;
    }
    /**
   * Returns quote streaming interval in seconds 
   * @return {number} quote streaming interval in seconds
   */ get quoteStreamingIntervalInSeconds() {
        return this._data.quoteStreamingIntervalInSeconds;
    }
    /**
   * Returns symbol provided by broker 
   * @return {string} any symbol provided by broker
   */ get symbol() {
        return this._data.symbol;
    }
    /**
   * Returns reliability value. Possible values are regular and high
   * @return {Reliability} account reliability value
   */ get reliability() {
        return this._data.reliability;
    }
    /**
   * Returns user-defined account tags
   * @return {Array<string>} user-defined account tags
   */ get tags() {
        return this._data.tags;
    }
    /**
   * Returns extra information which can be stored together with your account
   * @return {Object} extra information which can be stored together with your account
   */ get metadata() {
        return this._data.metadata;
    }
    /**
   * Returns number of resource slots to allocate to account. Allocating extra resource slots
   * results in better account performance under load which is useful for some applications. E.g. if you have many
   * accounts copying the same strategy via CopyFactory API, then you can increase resourceSlots to get a lower trade
   * copying latency. Please note that allocating extra resource slots is a paid option. Please note that high
   * reliability accounts use redundant infrastructure, so that each resource slot for a high reliability account
   * is billed as 2 standard resource slots.
   * @return {number} number of resource slots to allocate to account
   */ get resourceSlots() {
        return this._data.resourceSlots;
    }
    /**
   * Returns the number of CopyFactory 2 resource slots to allocate to account.
   * Allocating extra resource slots results in lower trade copying latency. Please note that allocating extra resource
   * slots is a paid option. Please also note that CopyFactory 2 uses redundant infrastructure so that
   * each CopyFactory resource slot is billed as 2 standard resource slots. You will be billed for CopyFactory 2
   * resource slots only if you have added your account to CopyFactory 2 by specifying copyFactoryRoles field.
   * @return {number} number of CopyFactory 2 resource slots to allocate to account
   */ get copyFactoryResourceSlots() {
        return this._data.copyFactoryResourceSlots;
    }
    /**
   * Returns account region
   * @return {string} account region value
   */ get region() {
        return this._data.region;
    }
    /**
   * Returns the time account was created at, in ISO format
   * @returns {string} the time account was created at, in ISO format
   */ get createdAt() {
        return new Date(this._data.createdAt);
    }
    /**
   * Returns human-readable account name
   * @return {string} human-readable account name
   */ get name() {
        return this._data.name;
    }
    /**
   * Returns flag indicating if trades should be placed as manual trades on this account
   * @return {boolean} flag indicating if trades should be placed as manual trades on this account
   */ get manualTrades() {
        return this._data.manualTrades;
    }
    /**
   * Returns default trade slippage in points
   * @return {number} default trade slippage in points
   */ get slippage() {
        return this._data.slippage;
    }
    /**
   * Returns id of the account's provisioning profile
   * @return {string} id of the account's provisioning profile
   */ get provisioningProfileId() {
        return this._data.provisioningProfileId;
    }
    /**
   * Returns MetaTrader account login
   * @return {string} MetaTrader account number
   */ get login() {
        return this._data.login;
    }
    /**
   * Returns MetaTrader server name to connect to
   * @return {string} MetaTrader server name to connect to
   */ get server() {
        return this._data.server;
    }
    /**
   * Returns account type. Possible values are cloud-g1, cloud-g2
   * @return {Type} account type
   */ get type() {
        return this._data.type;
    }
    /**
   * Returns MT version. Possible values are 4 and 5
   * @return {Version} MT version
   */ get version() {
        return this._data.version;
    }
    /**
   * Returns hash-code of the account
   * @return {number} hash-code of the account
   */ get hash() {
        return this._data.hash;
    }
    /**
   * Returns 3-character ISO currency code of the account base currency. The setting is to be used
   * for copy trading accounts which use national currencies only, such as some Brazilian brokers. You should not alter
   * this setting unless you understand what you are doing.
   * @return {number} 3-character ISO currency code of the account base currency
   */ get baseCurrency() {
        return this._data.baseCurrency;
    }
    /**
   * Returns account roles for CopyFactory2 application. Possible values are `PROVIDER` and `SUBSCRIBER`
   * @return {Array<CopyFactoryRoles>} account roles for CopyFactory2 application
   */ get copyFactoryRoles() {
        return this._data.copyFactoryRoles;
    }
    /**
   * Returns flag indicating that risk management API is enabled on account
   * @return {boolean} flag indicating that risk management API is enabled on account
   */ get riskManagementApiEnabled() {
        return this._data.riskManagementApiEnabled;
    }
    /**
   * Returns flag indicating that MetaStats API is enabled on account
   * @return {boolean} flag indicating that MetaStats API is enabled on account
   */ get metastatsApiEnabled() {
        return this._data.metastatsApiEnabled;
    }
    /**
   * Returns authorization access token to be used for accessing single account data.
   * Intended to be used in browser API.
   * @return {string} authorization token
   */ get accessToken() {
        return this._data.accessToken;
    }
    /**
   * Returns active account connections
   * @return {Array<AccountConnection>} active account connections
   */ get connections() {
        return this._data.connections;
    }
    /**
   * Returns flag indicating that account is primary
   * @return {boolean} flag indicating that account is primary
   */ get primaryReplica() {
        return this._data.primaryReplica;
    }
    /**
   * Returns user id
   * @return {string} user id
   */ get userId() {
        return this._data.userId;
    }
    /**
   * Returns primary account id
   * @return {string} primary account id
   */ get primaryAccountId() {
        return this._data.primaryAccountId;
    }
    /**
   * Returns account replicas from DTO
   * @return {MetatraderAccountReplica[]} account replicas from DTO
   */ get accountReplicas() {
        return this._data.accountReplicas;
    }
    /**
   * Returns account replica instances
   * @return {MetatraderAccountReplica[]} account replica instances
   */ get replicas() {
        return this._replicas;
    }
    /**
   * Returns a dictionary with account's available regions and replicas
   * @returns {{[region: string]: string}}
   */ get accountRegions() {
        const regions = {
            [this.region]: this.id
        };
        this.replicas.forEach((replica)=>regions[replica.region] = replica.id);
        return regions;
    }
    /**
   * Reloads MetaTrader account from API
   * @return {Promise} promise resolving when MetaTrader account is updated
   */ reload() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._data = yield _this._metatraderAccountClient.getAccount(_this.id);
            const updatedReplicaData = _this._data.accountReplicas || [];
            const regions = updatedReplicaData.map((replica)=>replica.region);
            const createdReplicaRegions = _this._replicas.map((replica)=>replica.region);
            _this._replicas = _this._replicas.filter((replica)=>regions.includes(replica.region));
            _this._replicas.forEach((replica)=>{
                const updatedData = updatedReplicaData.find((replicaData)=>replicaData.region === replica.region);
                replica.updateData(updatedData);
            });
            updatedReplicaData.forEach((replica)=>{
                if (!createdReplicaRegions.includes(replica.region)) {
                    _this._replicas.push(new MetatraderAccountReplica(replica, _this, _this._metatraderAccountClient));
                }
            });
        })();
    }
    /**
   * Removes a trading account and stops the API server serving the account.
   * The account state such as downloaded market data history will be removed as well when you remove the account.
   * @return {Promise} promise resolving when account is scheduled for deletion
   */ remove() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._connectionRegistry.remove(_this.id);
            yield _this._metatraderAccountClient.deleteAccount(_this.id);
            const fileManager = HistoryDatabase.getInstance();
            yield fileManager.clear(_this.id, _this._application);
            if (_this.type !== 'self-hosted') {
                try {
                    yield _this.reload();
                } catch (err) {
                    if (err.name !== 'NotFoundError') {
                        throw err;
                    }
                }
            }
        })();
    }
    /**
   * Starts API server and trading terminal for trading account.
   * This request will be ignored if the account is already deployed.
   * @returns {Promise} promise resolving when account is scheduled for deployment
   */ deploy() {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.deployAccount(_this.id);
            yield _this.reload();
        })();
    }
    /**
   * Stops API server and trading terminal for trading account.
   * This request will be ignored if trading account is already undeployed
   * @returns {Promise} promise resolving when account is scheduled for undeployment
   */ undeploy() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._connectionRegistry.remove(_this.id);
            yield _this._metatraderAccountClient.undeployAccount(_this.id);
            yield _this.reload();
        })();
    }
    /**
   * Redeploys trading account. This is equivalent to undeploy immediately followed by deploy
   * @returns {Promise} promise resolving when account is scheduled for redeployment
   */ redeploy() {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.redeployAccount(_this.id);
            yield _this.reload();
        })();
    }
    /**
   * Increases trading account reliability in order to increase the expected account uptime.
   * The account will be temporary stopped to perform this action.
   * Note that increasing reliability is a paid option
   * @returns {Promise} promise resolving when account reliability is increased
   */ increaseReliability() {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.increaseReliability(_this.id);
            yield _this.reload();
        })();
    }
    /**
   * Enables risk management API for trading account.
   * The account will be temporary stopped to perform this action.
   * Note that risk management API is a paid option
   * @returns {Promise} promise resolving when account risk management is enabled
   */ enableRiskManagementApi() {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.enableRiskManagementApi(_this.id);
            yield _this.reload();
        })();
    }
    /**
   * Enables MetaStats API for trading account.
   * The account will be temporary stopped to perform this action.
   * Note that this is a paid option
   * @returns {Promise} promise resolving when account MetaStats API is enabled
   */ enableMetaStatsApi() {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.enableMetaStatsApi(_this.id);
            yield _this.reload();
        })();
    }
    /**
   * Waits until API server has finished deployment and account reached the DEPLOYED state
   * @param {number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when account is deployed
   * @throws {TimeoutError} if account have not reached the DEPLOYED state within timeout allowed
   */ waitDeployed(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
        var _this = this;
        return _async_to_generator(function*() {
            let startTime = Date.now();
            yield _this.reload();
            while(_this.state !== 'DEPLOYED' && startTime + timeoutInSeconds * 1000 > Date.now()){
                yield _this._delay(intervalInMilliseconds);
                yield _this.reload();
            }
            if (_this.state !== 'DEPLOYED') {
                throw new TimeoutError('Timed out waiting for account ' + _this.id + ' to be deployed');
            }
        })();
    }
    /**
   * Waits until API server has finished undeployment and account reached the UNDEPLOYED state
   * @param {number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when account is deployed
   * @throws {TimeoutError} if account have not reached the UNDEPLOYED state within timeout allowed
   */ waitUndeployed(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
        var _this = this;
        return _async_to_generator(function*() {
            let startTime = Date.now();
            yield _this.reload();
            while(_this.state !== 'UNDEPLOYED' && startTime + timeoutInSeconds * 1000 > Date.now()){
                yield _this._delay(intervalInMilliseconds);
                yield _this.reload();
            }
            if (_this.state !== 'UNDEPLOYED') {
                throw new TimeoutError('Timed out waiting for account ' + _this.id + ' to be undeployed');
            }
        })();
    }
    /**
   * Waits until account has been deleted
   * @param {number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when account is deleted
   * @throws {TimeoutError} if account was not deleted within timeout allowed
   */ waitRemoved(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
        var _this = this;
        return _async_to_generator(function*() {
            let startTime = Date.now();
            try {
                yield _this.reload();
                while(startTime + timeoutInSeconds * 1000 > Date.now()){
                    yield _this._delay(intervalInMilliseconds);
                    yield _this.reload();
                }
                throw new TimeoutError('Timed out waiting for account ' + _this.id + ' to be deleted');
            } catch (err) {
                if (err.name === 'NotFoundError') {
                    return;
                } else {
                    throw err;
                }
            }
        })();
    }
    /**
   * Waits until API server has connected to the terminal and terminal has connected to the broker
   * @param {number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when API server is connected to the broker
   * @throws {TimeoutError} if account have not connected to the broker within timeout allowed
   */ waitConnected(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
        var _this = this;
        return _async_to_generator(function*() {
            const checkConnected = ()=>{
                return [
                    _this.connectionStatus
                ].concat(_this.replicas.map((replica)=>replica.connectionStatus)).includes('CONNECTED');
            };
            let startTime = Date.now();
            yield _this.reload();
            while(!checkConnected() && startTime + timeoutInSeconds * 1000 > Date.now()){
                yield _this._delay(intervalInMilliseconds);
                yield _this.reload();
            }
            if (!checkConnected()) {
                throw new TimeoutError('Timed out waiting for account ' + _this.id + ' to connect to the broker');
            }
        })();
    }
    /**
   * Connects to MetaApi. There is only one connection per account. Subsequent calls to this method will return the same connection.
   * @param {HistoryStorage} historyStorage optional history storage
   * @param {Date} [historyStartTime] history start time. Used for tests
   * @return {StreamingMetaApiConnectionInstance} MetaApi connection instance
   */ getStreamingConnection(historyStorage, historyStartTime) {
        if (this._metaApiWebsocketClient.region && this._metaApiWebsocketClient.region !== this.region) {
            throw new ValidationError(`Account ${this.id} is not on specified region ${this._metaApiWebsocketClient.region}`);
        }
        return this._connectionRegistry.connectStreaming(this, historyStorage, historyStartTime);
    }
    /**
   * Connects to MetaApi via RPC connection instance.
   * @returns {RpcMetaApiConnectionInstance} MetaApi connection instance
   */ getRPCConnection() {
        if (this._metaApiWebsocketClient.region && this._metaApiWebsocketClient.region !== this.region) {
            throw new ValidationError(`Account ${this.id} is not on specified region ${this._metaApiWebsocketClient.region}`);
        }
        return this._connectionRegistry.connectRpc(this);
    }
    /**
   * Updates trading account. 
   * Please redeploy the trading account in order for updated settings to take effect
   * @param {MetatraderAccountUpdateDto} account updated account information
   * @return {Promise} promise resolving when account is updated
   */ update(account) {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.updateAccount(_this.id, account);
            yield _this.reload();
        })();
    }
    /**
   * Creates a trading account replica in a region different from trading account region and starts a cloud API server for it
   * @param {NewMetaTraderAccountDto} account MetaTrader account data
   * @return {Promise<MetatraderAccountReplica>} promise resolving with created MetaTrader account replica entity
   */ createReplica(account) {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.createAccountReplica(_this.id, account);
            yield _this.reload();
            return _this._replicas.find((r)=>r.region === account.region);
        })();
    }
    /**
   * Retrieves expert advisor of current account
   * @returns {Promise<ExpertAdvisor[]>} promise resolving with an array of expert advisor entities
   */ getExpertAdvisors() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkExpertAdvisorAllowed();
            let expertAdvisors = yield _this._expertAdvisorClient.getExpertAdvisors(_this.id);
            return expertAdvisors.map((e)=>new ExpertAdvisor(e, _this.id, _this._expertAdvisorClient));
        })();
    }
    /**
   * Retrieves a expert advisor of current account by id
   * @param {String} expertId expert advisor id
   * @returns {Promise<ExpertAdvisor>} promise resolving with expert advisor entity
   */ getExpertAdvisor(expertId) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkExpertAdvisorAllowed();
            let expertAdvisor = yield _this._expertAdvisorClient.getExpertAdvisor(_this.id, expertId);
            return new ExpertAdvisor(expertAdvisor, _this.id, _this._expertAdvisorClient);
        })();
    }
    /**
   * Creates an expert advisor
   * @param {string} expertId expert advisor id
   * @param {NewExpertAdvisorDto} expert expert advisor data
   * @returns {Promise<ExpertAdvisor>} promise resolving with expert advisor entity
   */ createExpertAdvisor(expertId, expert) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkExpertAdvisorAllowed();
            yield _this._expertAdvisorClient.updateExpertAdvisor(_this.id, expertId, expert);
            return _this.getExpertAdvisor(expertId);
        })();
    }
    /**
   * Returns historical candles for a specific symbol and timeframe from the MetaTrader account.
   * See https://metaapi.cloud/docs/client/restApi/api/retrieveMarketData/readHistoricalCandles/
   * @param {string} symbol symbol to retrieve candles for (e.g. a currency pair or an index)
   * @param {string} timeframe defines the timeframe according to which the candles must be generated. Allowed values
   * for MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed
   * values for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @param {Date} [startTime] time to start loading candles from. Note that candles are loaded in backwards direction, so
   * this should be the latest time. Leave empty to request latest candles.
   * @param {number} [limit] maximum number of candles to retrieve. Must be less or equal to 1000
   * @return {Promise<Array<MetatraderCandle>>} promise resolving with historical candles downloaded
   */ getHistoricalCandles(symbol, timeframe, startTime, limit) {
        return this._historicalMarketDataClient.getHistoricalCandles(this.id, this.region, symbol, timeframe, startTime, limit);
    }
    /**
   * Returns historical ticks for a specific symbol from the MetaTrader account. This API is not supported by MT4
   * accounts.
   * See https://metaapi.cloud/docs/client/restApi/api/retrieveMarketData/readHistoricalTicks/
   * @param {string} symbol symbol to retrieve ticks for (e.g. a currency pair or an index)
   * @param {Date} [startTime] time to start loading ticks from. Note that candles are loaded in forward direction, so
   * this should be the earliest time. Leave empty to request latest candles.
   * @param {number} [offset] number of ticks to skip (you can use it to avoid requesting ticks from previous request
   * twice)
   * @param {number} [limit] maximum number of ticks to retrieve. Must be less or equal to 1000
   * @return {Promise<Array<MetatraderTick>>} promise resolving with historical ticks downloaded
   */ getHistoricalTicks(symbol, startTime, offset, limit) {
        return this._historicalMarketDataClient.getHistoricalTicks(this.id, this.region, symbol, startTime, offset, limit);
    }
    /**
   * Generates trading account configuration link by account id.
   * @param {number} [ttlInDays] Lifetime of the link in days. Default is 7.
   * @return {Promise<ConfigurationLink>} promise resolving with configuration link
   */ createConfigurationLink(ttlInDays) {
        var _this = this;
        return _async_to_generator(function*() {
            const configurationLink = yield _this._metatraderAccountClient.createConfigurationLink(_this.id, ttlInDays);
            return configurationLink;
        })();
    }
    _checkExpertAdvisorAllowed() {
        if (this.version !== 4 || this.type !== 'cloud-g1') {
            throw new ValidationError('Custom expert advisor is available only for MT4 G1 accounts');
        }
    }
    _delay(timeoutInMilliseconds) {
        return new Promise((res)=>setTimeout(res, timeoutInMilliseconds));
    }
    /**
   * Constructs a MetaTrader account entity
   * @param {MetatraderAccountDto} data MetaTrader account data
   * @param {MetatraderAccountClient} metatraderAccountClient MetaTrader account REST API client
   * @param {MetaApiWebsocketClient} metaApiWebsocketClient MetaApi websocket client
   * @param {ConnectionRegistry} connectionRegistry metatrader account connection registry
   * @param {ExpertAdvisorClient} expertAdvisorClient expert advisor REST API client
   * @param {HistoricalMarketDataClient} historicalMarketDataClient historical market data HTTP API client
   * @param {string} application application name
   */ constructor(data, metatraderAccountClient, metaApiWebsocketClient, connectionRegistry, expertAdvisorClient, historicalMarketDataClient, application){
        this._data = data;
        this._metatraderAccountClient = metatraderAccountClient;
        this._metaApiWebsocketClient = metaApiWebsocketClient;
        this._connectionRegistry = connectionRegistry;
        this._expertAdvisorClient = expertAdvisorClient;
        this._historicalMarketDataClient = historicalMarketDataClient;
        this._application = application;
        this._replicas = (data.accountReplicas || []).map((replica)=>new MetatraderAccountReplica(replica, this, metatraderAccountClient));
    }
};
/**
 * Implements a MetaTrader account entity
 */ export { MetatraderAccount as default };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUaW1lb3V0RXJyb3IgZnJvbSAnLi4vY2xpZW50cy90aW1lb3V0RXJyb3InO1xuaW1wb3J0IFJwY01ldGFBcGlDb25uZWN0aW9uSW5zdGFuY2UgZnJvbSAnLi9ycGNNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlJztcbmltcG9ydCBTdHJlYW1pbmdNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlIGZyb20gJy4vc3RyZWFtaW5nTWV0YUFwaUNvbm5lY3Rpb25JbnN0YW5jZSc7XG5pbXBvcnQgSGlzdG9yeURhdGFiYXNlIGZyb20gJy4vaGlzdG9yeURhdGFiYXNlL2luZGV4JztcbmltcG9ydCBFeHBlcnRBZHZpc29yIGZyb20gJy4vZXhwZXJ0QWR2aXNvcic7XG5pbXBvcnQge1ZhbGlkYXRpb25FcnJvcn0gZnJvbSAnLi4vY2xpZW50cy9lcnJvckhhbmRsZXInO1xuaW1wb3J0IE1ldGF0cmFkZXJBY2NvdW50UmVwbGljYSBmcm9tICcuL21ldGF0cmFkZXJBY2NvdW50UmVwbGljYSc7XG4vL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5pbXBvcnQge1JlbGlhYmlsaXR5LCBTdGF0ZSwgVmVyc2lvbiwgQ29ubmVjdGlvblN0YXR1cywgQ29weUZhY3RvcnlSb2xlcywgVHlwZSwgQWNjb3VudENvbm5lY3Rpb24sIENvbmZpZ3VyYXRpb25MaW5rfSBmcm9tICcuLi9jbGllbnRzL21ldGFBcGkvbWV0YXRyYWRlckFjY291bnQuY2xpZW50JztcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgTWV0YVRyYWRlciBhY2NvdW50IGVudGl0eVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZXRhdHJhZGVyQWNjb3VudCB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBNZXRhVHJhZGVyIGFjY291bnQgZW50aXR5XG4gICAqIEBwYXJhbSB7TWV0YXRyYWRlckFjY291bnREdG99IGRhdGEgTWV0YVRyYWRlciBhY2NvdW50IGRhdGFcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyQWNjb3VudENsaWVudH0gbWV0YXRyYWRlckFjY291bnRDbGllbnQgTWV0YVRyYWRlciBhY2NvdW50IFJFU1QgQVBJIGNsaWVudFxuICAgKiBAcGFyYW0ge01ldGFBcGlXZWJzb2NrZXRDbGllbnR9IG1ldGFBcGlXZWJzb2NrZXRDbGllbnQgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50XG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvblJlZ2lzdHJ5fSBjb25uZWN0aW9uUmVnaXN0cnkgbWV0YXRyYWRlciBhY2NvdW50IGNvbm5lY3Rpb24gcmVnaXN0cnlcbiAgICogQHBhcmFtIHtFeHBlcnRBZHZpc29yQ2xpZW50fSBleHBlcnRBZHZpc29yQ2xpZW50IGV4cGVydCBhZHZpc29yIFJFU1QgQVBJIGNsaWVudFxuICAgKiBAcGFyYW0ge0hpc3RvcmljYWxNYXJrZXREYXRhQ2xpZW50fSBoaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudCBoaXN0b3JpY2FsIG1hcmtldCBkYXRhIEhUVFAgQVBJIGNsaWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwbGljYXRpb24gYXBwbGljYXRpb24gbmFtZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSwgbWV0YXRyYWRlckFjY291bnRDbGllbnQsIG1ldGFBcGlXZWJzb2NrZXRDbGllbnQsIGNvbm5lY3Rpb25SZWdpc3RyeSwgZXhwZXJ0QWR2aXNvckNsaWVudCwgXG4gICAgaGlzdG9yaWNhbE1hcmtldERhdGFDbGllbnQsIGFwcGxpY2F0aW9uKSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQgPSBtZXRhdHJhZGVyQWNjb3VudENsaWVudDtcbiAgICB0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50ID0gbWV0YUFwaVdlYnNvY2tldENsaWVudDtcbiAgICB0aGlzLl9jb25uZWN0aW9uUmVnaXN0cnkgPSBjb25uZWN0aW9uUmVnaXN0cnk7XG4gICAgdGhpcy5fZXhwZXJ0QWR2aXNvckNsaWVudCA9IGV4cGVydEFkdmlzb3JDbGllbnQ7XG4gICAgdGhpcy5faGlzdG9yaWNhbE1hcmtldERhdGFDbGllbnQgPSBoaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudDtcbiAgICB0aGlzLl9hcHBsaWNhdGlvbiA9IGFwcGxpY2F0aW9uO1xuICAgIHRoaXMuX3JlcGxpY2FzID0gKGRhdGEuYWNjb3VudFJlcGxpY2FzIHx8IFtdKVxuICAgICAgLm1hcChyZXBsaWNhID0+IG5ldyBNZXRhdHJhZGVyQWNjb3VudFJlcGxpY2EocmVwbGljYSwgdGhpcywgbWV0YXRyYWRlckFjY291bnRDbGllbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHVuaXF1ZSBhY2NvdW50IGlkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gdW5pcXVlIGFjY291bnQgaWRcbiAgICovXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5faWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IGFjY291bnQgc3RhdGUuIE9uZSBvZiBDUkVBVEVELCBERVBMT1lJTkcsIERFUExPWUVELCBERVBMT1lfRkFJTEVELCBVTkRFUExPWUlORyxcbiAgICogVU5ERVBMT1lFRCwgVU5ERVBMT1lfRkFJTEVELCBERUxFVElORywgREVMRVRFX0ZBSUxFRCwgUkVERVBMT1lfRkFJTEVELCBEUkFGVFxuICAgKiBAcmV0dXJuIHtTdGF0ZX0gY3VycmVudCBhY2NvdW50IHN0YXRlXG4gICAqL1xuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBNZXRhVHJhZGVyIG1hZ2ljIHRvIHBsYWNlIHRyYWRlcyB1c2luZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1ldGFUcmFkZXIgbWFnaWMgdG8gcGxhY2UgdHJhZGVzIHVzaW5nXG4gICAqL1xuICBnZXQgbWFnaWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubWFnaWM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0ZXJtaW5hbCAmIGJyb2tlciBjb25uZWN0aW9uIHN0YXR1cywgb25lIG9mIENPTk5FQ1RFRCwgRElTQ09OTkVDVEVELCBESVNDT05ORUNURURfRlJPTV9CUk9LRVJcbiAgICogQHJldHVybiB7Q29ubmVjdGlvblN0YXR1c30gdGVybWluYWwgJiBicm9rZXIgY29ubmVjdGlvbiBzdGF0dXNcbiAgICovXG4gIGdldCBjb25uZWN0aW9uU3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmNvbm5lY3Rpb25TdGF0dXM7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHF1b3RlIHN0cmVhbWluZyBpbnRlcnZhbCBpbiBzZWNvbmRzIFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHF1b3RlIHN0cmVhbWluZyBpbnRlcnZhbCBpbiBzZWNvbmRzXG4gICAqL1xuICBnZXQgcXVvdGVTdHJlYW1pbmdJbnRlcnZhbEluU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5xdW90ZVN0cmVhbWluZ0ludGVydmFsSW5TZWNvbmRzO1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJucyBzeW1ib2wgcHJvdmlkZWQgYnkgYnJva2VyIFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGFueSBzeW1ib2wgcHJvdmlkZWQgYnkgYnJva2VyXG4gICAqL1xuICBnZXQgc3ltYm9sKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnN5bWJvbDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJldHVybnMgcmVsaWFiaWxpdHkgdmFsdWUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgcmVndWxhciBhbmQgaGlnaFxuICAgKiBAcmV0dXJuIHtSZWxpYWJpbGl0eX0gYWNjb3VudCByZWxpYWJpbGl0eSB2YWx1ZVxuICAgKi9cbiAgZ2V0IHJlbGlhYmlsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlbGlhYmlsaXR5O1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJucyB1c2VyLWRlZmluZWQgYWNjb3VudCB0YWdzXG4gICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IHVzZXItZGVmaW5lZCBhY2NvdW50IHRhZ3NcbiAgICovXG4gIGdldCB0YWdzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnRhZ3M7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBleHRyYSBpbmZvcm1hdGlvbiB3aGljaCBjYW4gYmUgc3RvcmVkIHRvZ2V0aGVyIHdpdGggeW91ciBhY2NvdW50XG4gICAqIEByZXR1cm4ge09iamVjdH0gZXh0cmEgaW5mb3JtYXRpb24gd2hpY2ggY2FuIGJlIHN0b3JlZCB0b2dldGhlciB3aXRoIHlvdXIgYWNjb3VudFxuICAgKi9cbiAgZ2V0IG1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLm1ldGFkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbnVtYmVyIG9mIHJlc291cmNlIHNsb3RzIHRvIGFsbG9jYXRlIHRvIGFjY291bnQuIEFsbG9jYXRpbmcgZXh0cmEgcmVzb3VyY2Ugc2xvdHNcbiAgICogcmVzdWx0cyBpbiBiZXR0ZXIgYWNjb3VudCBwZXJmb3JtYW5jZSB1bmRlciBsb2FkIHdoaWNoIGlzIHVzZWZ1bCBmb3Igc29tZSBhcHBsaWNhdGlvbnMuIEUuZy4gaWYgeW91IGhhdmUgbWFueVxuICAgKiBhY2NvdW50cyBjb3B5aW5nIHRoZSBzYW1lIHN0cmF0ZWd5IHZpYSBDb3B5RmFjdG9yeSBBUEksIHRoZW4geW91IGNhbiBpbmNyZWFzZSByZXNvdXJjZVNsb3RzIHRvIGdldCBhIGxvd2VyIHRyYWRlXG4gICAqIGNvcHlpbmcgbGF0ZW5jeS4gUGxlYXNlIG5vdGUgdGhhdCBhbGxvY2F0aW5nIGV4dHJhIHJlc291cmNlIHNsb3RzIGlzIGEgcGFpZCBvcHRpb24uIFBsZWFzZSBub3RlIHRoYXQgaGlnaFxuICAgKiByZWxpYWJpbGl0eSBhY2NvdW50cyB1c2UgcmVkdW5kYW50IGluZnJhc3RydWN0dXJlLCBzbyB0aGF0IGVhY2ggcmVzb3VyY2Ugc2xvdCBmb3IgYSBoaWdoIHJlbGlhYmlsaXR5IGFjY291bnRcbiAgICogaXMgYmlsbGVkIGFzIDIgc3RhbmRhcmQgcmVzb3VyY2Ugc2xvdHMuXG4gICAqIEByZXR1cm4ge251bWJlcn0gbnVtYmVyIG9mIHJlc291cmNlIHNsb3RzIHRvIGFsbG9jYXRlIHRvIGFjY291bnRcbiAgICovXG4gIGdldCByZXNvdXJjZVNsb3RzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlc291cmNlU2xvdHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIENvcHlGYWN0b3J5IDIgcmVzb3VyY2Ugc2xvdHMgdG8gYWxsb2NhdGUgdG8gYWNjb3VudC5cbiAgICogQWxsb2NhdGluZyBleHRyYSByZXNvdXJjZSBzbG90cyByZXN1bHRzIGluIGxvd2VyIHRyYWRlIGNvcHlpbmcgbGF0ZW5jeS4gUGxlYXNlIG5vdGUgdGhhdCBhbGxvY2F0aW5nIGV4dHJhIHJlc291cmNlXG4gICAqIHNsb3RzIGlzIGEgcGFpZCBvcHRpb24uIFBsZWFzZSBhbHNvIG5vdGUgdGhhdCBDb3B5RmFjdG9yeSAyIHVzZXMgcmVkdW5kYW50IGluZnJhc3RydWN0dXJlIHNvIHRoYXRcbiAgICogZWFjaCBDb3B5RmFjdG9yeSByZXNvdXJjZSBzbG90IGlzIGJpbGxlZCBhcyAyIHN0YW5kYXJkIHJlc291cmNlIHNsb3RzLiBZb3Ugd2lsbCBiZSBiaWxsZWQgZm9yIENvcHlGYWN0b3J5IDJcbiAgICogcmVzb3VyY2Ugc2xvdHMgb25seSBpZiB5b3UgaGF2ZSBhZGRlZCB5b3VyIGFjY291bnQgdG8gQ29weUZhY3RvcnkgMiBieSBzcGVjaWZ5aW5nIGNvcHlGYWN0b3J5Um9sZXMgZmllbGQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gbnVtYmVyIG9mIENvcHlGYWN0b3J5IDIgcmVzb3VyY2Ugc2xvdHMgdG8gYWxsb2NhdGUgdG8gYWNjb3VudFxuICAgKi9cbiAgZ2V0IGNvcHlGYWN0b3J5UmVzb3VyY2VTbG90cygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5jb3B5RmFjdG9yeVJlc291cmNlU2xvdHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IHJlZ2lvblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGFjY291bnQgcmVnaW9uIHZhbHVlXG4gICAqL1xuICBnZXQgcmVnaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlZ2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0aW1lIGFjY291bnQgd2FzIGNyZWF0ZWQgYXQsIGluIElTTyBmb3JtYXRcbiAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHRpbWUgYWNjb3VudCB3YXMgY3JlYXRlZCBhdCwgaW4gSVNPIGZvcm1hdFxuICAgKi9cbiAgZ2V0IGNyZWF0ZWRBdCgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZGF0YS5jcmVhdGVkQXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaHVtYW4tcmVhZGFibGUgYWNjb3VudCBuYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ30gaHVtYW4tcmVhZGFibGUgYWNjb3VudCBuYW1lXG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5uYW1lO1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJucyBmbGFnIGluZGljYXRpbmcgaWYgdHJhZGVzIHNob3VsZCBiZSBwbGFjZWQgYXMgbWFudWFsIHRyYWRlcyBvbiB0aGlzIGFjY291bnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gZmxhZyBpbmRpY2F0aW5nIGlmIHRyYWRlcyBzaG91bGQgYmUgcGxhY2VkIGFzIG1hbnVhbCB0cmFkZXMgb24gdGhpcyBhY2NvdW50XG4gICAqL1xuICBnZXQgbWFudWFsVHJhZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLm1hbnVhbFRyYWRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGRlZmF1bHQgdHJhZGUgc2xpcHBhZ2UgaW4gcG9pbnRzXG4gICAqIEByZXR1cm4ge251bWJlcn0gZGVmYXVsdCB0cmFkZSBzbGlwcGFnZSBpbiBwb2ludHNcbiAgICovXG4gIGdldCBzbGlwcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zbGlwcGFnZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJldHVybnMgaWQgb2YgdGhlIGFjY291bnQncyBwcm92aXNpb25pbmcgcHJvZmlsZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGlkIG9mIHRoZSBhY2NvdW50J3MgcHJvdmlzaW9uaW5nIHByb2ZpbGVcbiAgICovXG4gIGdldCBwcm92aXNpb25pbmdQcm9maWxlSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucHJvdmlzaW9uaW5nUHJvZmlsZUlkO1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJucyBNZXRhVHJhZGVyIGFjY291bnQgbG9naW5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNZXRhVHJhZGVyIGFjY291bnQgbnVtYmVyXG4gICAqL1xuICBnZXQgbG9naW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubG9naW47XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIE1ldGFUcmFkZXIgc2VydmVyIG5hbWUgdG8gY29ubmVjdCB0b1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1ldGFUcmFkZXIgc2VydmVyIG5hbWUgdG8gY29ubmVjdCB0b1xuICAgKi9cbiAgZ2V0IHNlcnZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zZXJ2ZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IHR5cGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgY2xvdWQtZzEsIGNsb3VkLWcyXG4gICAqIEByZXR1cm4ge1R5cGV9IGFjY291bnQgdHlwZVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEudHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE1UIHZlcnNpb24uIFBvc3NpYmxlIHZhbHVlcyBhcmUgNCBhbmQgNVxuICAgKiBAcmV0dXJuIHtWZXJzaW9ufSBNVCB2ZXJzaW9uXG4gICAqL1xuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS52ZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGFzaC1jb2RlIG9mIHRoZSBhY2NvdW50XG4gICAqIEByZXR1cm4ge251bWJlcn0gaGFzaC1jb2RlIG9mIHRoZSBhY2NvdW50XG4gICAqL1xuICBnZXQgaGFzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5oYXNoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgMy1jaGFyYWN0ZXIgSVNPIGN1cnJlbmN5IGNvZGUgb2YgdGhlIGFjY291bnQgYmFzZSBjdXJyZW5jeS4gVGhlIHNldHRpbmcgaXMgdG8gYmUgdXNlZFxuICAgKiBmb3IgY29weSB0cmFkaW5nIGFjY291bnRzIHdoaWNoIHVzZSBuYXRpb25hbCBjdXJyZW5jaWVzIG9ubHksIHN1Y2ggYXMgc29tZSBCcmF6aWxpYW4gYnJva2Vycy4gWW91IHNob3VsZCBub3QgYWx0ZXJcbiAgICogdGhpcyBzZXR0aW5nIHVubGVzcyB5b3UgdW5kZXJzdGFuZCB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gMy1jaGFyYWN0ZXIgSVNPIGN1cnJlbmN5IGNvZGUgb2YgdGhlIGFjY291bnQgYmFzZSBjdXJyZW5jeVxuICAgKi9cbiAgZ2V0IGJhc2VDdXJyZW5jeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5iYXNlQ3VycmVuY3k7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IHJvbGVzIGZvciBDb3B5RmFjdG9yeTIgYXBwbGljYXRpb24uIFBvc3NpYmxlIHZhbHVlcyBhcmUgYFBST1ZJREVSYCBhbmQgYFNVQlNDUklCRVJgXG4gICAqIEByZXR1cm4ge0FycmF5PENvcHlGYWN0b3J5Um9sZXM+fSBhY2NvdW50IHJvbGVzIGZvciBDb3B5RmFjdG9yeTIgYXBwbGljYXRpb25cbiAgICovXG4gIGdldCBjb3B5RmFjdG9yeVJvbGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmNvcHlGYWN0b3J5Um9sZXM7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZsYWcgaW5kaWNhdGluZyB0aGF0IHJpc2sgbWFuYWdlbWVudCBBUEkgaXMgZW5hYmxlZCBvbiBhY2NvdW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGZsYWcgaW5kaWNhdGluZyB0aGF0IHJpc2sgbWFuYWdlbWVudCBBUEkgaXMgZW5hYmxlZCBvbiBhY2NvdW50XG4gICAqL1xuICBnZXQgcmlza01hbmFnZW1lbnRBcGlFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJpc2tNYW5hZ2VtZW50QXBpRW5hYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZsYWcgaW5kaWNhdGluZyB0aGF0IE1ldGFTdGF0cyBBUEkgaXMgZW5hYmxlZCBvbiBhY2NvdW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGZsYWcgaW5kaWNhdGluZyB0aGF0IE1ldGFTdGF0cyBBUEkgaXMgZW5hYmxlZCBvbiBhY2NvdW50XG4gICAqL1xuICBnZXQgbWV0YXN0YXRzQXBpRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5tZXRhc3RhdHNBcGlFbmFibGVkO1xuICB9XG4gICAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIGF1dGhvcml6YXRpb24gYWNjZXNzIHRva2VuIHRvIGJlIHVzZWQgZm9yIGFjY2Vzc2luZyBzaW5nbGUgYWNjb3VudCBkYXRhLlxuICAgKiBJbnRlbmRlZCB0byBiZSB1c2VkIGluIGJyb3dzZXIgQVBJLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGF1dGhvcml6YXRpb24gdG9rZW5cbiAgICovXG4gIGdldCBhY2Nlc3NUb2tlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5hY2Nlc3NUb2tlbjtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJldHVybnMgYWN0aXZlIGFjY291bnQgY29ubmVjdGlvbnNcbiAgICogQHJldHVybiB7QXJyYXk8QWNjb3VudENvbm5lY3Rpb24+fSBhY3RpdmUgYWNjb3VudCBjb25uZWN0aW9uc1xuICAgKi9cbiAgZ2V0IGNvbm5lY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmNvbm5lY3Rpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmxhZyBpbmRpY2F0aW5nIHRoYXQgYWNjb3VudCBpcyBwcmltYXJ5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGZsYWcgaW5kaWNhdGluZyB0aGF0IGFjY291bnQgaXMgcHJpbWFyeVxuICAgKi9cbiAgZ2V0IHByaW1hcnlSZXBsaWNhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnByaW1hcnlSZXBsaWNhO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdXNlciBpZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHVzZXIgaWRcbiAgICovXG4gIGdldCB1c2VySWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEudXNlcklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcHJpbWFyeSBhY2NvdW50IGlkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gcHJpbWFyeSBhY2NvdW50IGlkXG4gICAqL1xuICBnZXQgcHJpbWFyeUFjY291bnRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5wcmltYXJ5QWNjb3VudElkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWNjb3VudCByZXBsaWNhcyBmcm9tIERUT1xuICAgKiBAcmV0dXJuIHtNZXRhdHJhZGVyQWNjb3VudFJlcGxpY2FbXX0gYWNjb3VudCByZXBsaWNhcyBmcm9tIERUT1xuICAgKi9cbiAgZ2V0IGFjY291bnRSZXBsaWNhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5hY2NvdW50UmVwbGljYXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IHJlcGxpY2EgaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJBY2NvdW50UmVwbGljYVtdfSBhY2NvdW50IHJlcGxpY2EgaW5zdGFuY2VzXG4gICAqL1xuICBnZXQgcmVwbGljYXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcGxpY2FzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBkaWN0aW9uYXJ5IHdpdGggYWNjb3VudCdzIGF2YWlsYWJsZSByZWdpb25zIGFuZCByZXBsaWNhc1xuICAgKiBAcmV0dXJucyB7e1tyZWdpb246IHN0cmluZ106IHN0cmluZ319XG4gICAqL1xuICBnZXQgYWNjb3VudFJlZ2lvbnMoKSB7XG4gICAgY29uc3QgcmVnaW9ucyA9IHtbdGhpcy5yZWdpb25dOiB0aGlzLmlkfTtcbiAgICB0aGlzLnJlcGxpY2FzLmZvckVhY2gocmVwbGljYSA9PiByZWdpb25zW3JlcGxpY2EucmVnaW9uXSA9IHJlcGxpY2EuaWQpO1xuICAgIHJldHVybiByZWdpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbG9hZHMgTWV0YVRyYWRlciBhY2NvdW50IGZyb20gQVBJXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gTWV0YVRyYWRlciBhY2NvdW50IGlzIHVwZGF0ZWRcbiAgICovXG4gIGFzeW5jIHJlbG9hZCgpIHtcbiAgICB0aGlzLl9kYXRhID0gYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQuZ2V0QWNjb3VudCh0aGlzLmlkKTtcbiAgICBjb25zdCB1cGRhdGVkUmVwbGljYURhdGEgPSAodGhpcy5fZGF0YS5hY2NvdW50UmVwbGljYXMgfHwgW10pO1xuICAgIGNvbnN0IHJlZ2lvbnMgPSB1cGRhdGVkUmVwbGljYURhdGEubWFwKHJlcGxpY2EgPT4gcmVwbGljYS5yZWdpb24pO1xuICAgIGNvbnN0IGNyZWF0ZWRSZXBsaWNhUmVnaW9ucyA9IHRoaXMuX3JlcGxpY2FzLm1hcChyZXBsaWNhID0+IHJlcGxpY2EucmVnaW9uKTtcbiAgICB0aGlzLl9yZXBsaWNhcyA9IHRoaXMuX3JlcGxpY2FzLmZpbHRlcihyZXBsaWNhID0+IHJlZ2lvbnMuaW5jbHVkZXMocmVwbGljYS5yZWdpb24pKTtcbiAgICB0aGlzLl9yZXBsaWNhcy5mb3JFYWNoKHJlcGxpY2EgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSB1cGRhdGVkUmVwbGljYURhdGEuZmluZChyZXBsaWNhRGF0YSA9PiByZXBsaWNhRGF0YS5yZWdpb24gPT09IHJlcGxpY2EucmVnaW9uKTtcbiAgICAgIHJlcGxpY2EudXBkYXRlRGF0YSh1cGRhdGVkRGF0YSk7XG4gICAgfSk7XG4gICAgdXBkYXRlZFJlcGxpY2FEYXRhLmZvckVhY2gocmVwbGljYSA9PiB7XG4gICAgICBpZighY3JlYXRlZFJlcGxpY2FSZWdpb25zLmluY2x1ZGVzKHJlcGxpY2EucmVnaW9uKSkge1xuICAgICAgICB0aGlzLl9yZXBsaWNhcy5wdXNoKG5ldyBNZXRhdHJhZGVyQWNjb3VudFJlcGxpY2EocmVwbGljYSwgdGhpcywgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgdHJhZGluZyBhY2NvdW50IGFuZCBzdG9wcyB0aGUgQVBJIHNlcnZlciBzZXJ2aW5nIHRoZSBhY2NvdW50LlxuICAgKiBUaGUgYWNjb3VudCBzdGF0ZSBzdWNoIGFzIGRvd25sb2FkZWQgbWFya2V0IGRhdGEgaGlzdG9yeSB3aWxsIGJlIHJlbW92ZWQgYXMgd2VsbCB3aGVuIHlvdSByZW1vdmUgdGhlIGFjY291bnQuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gYWNjb3VudCBpcyBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uXG4gICAqL1xuICBhc3luYyByZW1vdmUoKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5LnJlbW92ZSh0aGlzLmlkKTtcbiAgICBhd2FpdCB0aGlzLl9tZXRhdHJhZGVyQWNjb3VudENsaWVudC5kZWxldGVBY2NvdW50KHRoaXMuaWQpO1xuICAgIGNvbnN0IGZpbGVNYW5hZ2VyID0gSGlzdG9yeURhdGFiYXNlLmdldEluc3RhbmNlKCk7XG4gICAgYXdhaXQgZmlsZU1hbmFnZXIuY2xlYXIodGhpcy5pZCwgdGhpcy5fYXBwbGljYXRpb24pO1xuICAgIGlmICh0aGlzLnR5cGUgIT09ICdzZWxmLWhvc3RlZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5uYW1lICE9PSAnTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIEFQSSBzZXJ2ZXIgYW5kIHRyYWRpbmcgdGVybWluYWwgZm9yIHRyYWRpbmcgYWNjb3VudC5cbiAgICogVGhpcyByZXF1ZXN0IHdpbGwgYmUgaWdub3JlZCBpZiB0aGUgYWNjb3VudCBpcyBhbHJlYWR5IGRlcGxveWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhY2NvdW50IGlzIHNjaGVkdWxlZCBmb3IgZGVwbG95bWVudFxuICAgKi9cbiAgYXN5bmMgZGVwbG95KCkge1xuICAgIGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LmRlcGxveUFjY291bnQodGhpcy5pZCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBBUEkgc2VydmVyIGFuZCB0cmFkaW5nIHRlcm1pbmFsIGZvciB0cmFkaW5nIGFjY291bnQuXG4gICAqIFRoaXMgcmVxdWVzdCB3aWxsIGJlIGlnbm9yZWQgaWYgdHJhZGluZyBhY2NvdW50IGlzIGFscmVhZHkgdW5kZXBsb3llZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhY2NvdW50IGlzIHNjaGVkdWxlZCBmb3IgdW5kZXBsb3ltZW50XG4gICAqL1xuICBhc3luYyB1bmRlcGxveSgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uUmVnaXN0cnkucmVtb3ZlKHRoaXMuaWQpO1xuICAgIGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LnVuZGVwbG95QWNjb3VudCh0aGlzLmlkKTtcbiAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZGVwbG95cyB0cmFkaW5nIGFjY291bnQuIFRoaXMgaXMgZXF1aXZhbGVudCB0byB1bmRlcGxveSBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBkZXBsb3lcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gYWNjb3VudCBpcyBzY2hlZHVsZWQgZm9yIHJlZGVwbG95bWVudFxuICAgKi9cbiAgYXN5bmMgcmVkZXBsb3koKSB7XG4gICAgYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQucmVkZXBsb3lBY2NvdW50KHRoaXMuaWQpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2VzIHRyYWRpbmcgYWNjb3VudCByZWxpYWJpbGl0eSBpbiBvcmRlciB0byBpbmNyZWFzZSB0aGUgZXhwZWN0ZWQgYWNjb3VudCB1cHRpbWUuXG4gICAqIFRoZSBhY2NvdW50IHdpbGwgYmUgdGVtcG9yYXJ5IHN0b3BwZWQgdG8gcGVyZm9ybSB0aGlzIGFjdGlvbi5cbiAgICogTm90ZSB0aGF0IGluY3JlYXNpbmcgcmVsaWFiaWxpdHkgaXMgYSBwYWlkIG9wdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhY2NvdW50IHJlbGlhYmlsaXR5IGlzIGluY3JlYXNlZFxuICAgKi9cbiAgYXN5bmMgaW5jcmVhc2VSZWxpYWJpbGl0eSgpIHtcbiAgICBhd2FpdCB0aGlzLl9tZXRhdHJhZGVyQWNjb3VudENsaWVudC5pbmNyZWFzZVJlbGlhYmlsaXR5KHRoaXMuaWQpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyByaXNrIG1hbmFnZW1lbnQgQVBJIGZvciB0cmFkaW5nIGFjY291bnQuXG4gICAqIFRoZSBhY2NvdW50IHdpbGwgYmUgdGVtcG9yYXJ5IHN0b3BwZWQgdG8gcGVyZm9ybSB0aGlzIGFjdGlvbi5cbiAgICogTm90ZSB0aGF0IHJpc2sgbWFuYWdlbWVudCBBUEkgaXMgYSBwYWlkIG9wdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhY2NvdW50IHJpc2sgbWFuYWdlbWVudCBpcyBlbmFibGVkXG4gICAqL1xuICBhc3luYyBlbmFibGVSaXNrTWFuYWdlbWVudEFwaSgpIHtcbiAgICBhd2FpdCB0aGlzLl9tZXRhdHJhZGVyQWNjb3VudENsaWVudC5lbmFibGVSaXNrTWFuYWdlbWVudEFwaSh0aGlzLmlkKTtcbiAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgTWV0YVN0YXRzIEFQSSBmb3IgdHJhZGluZyBhY2NvdW50LlxuICAgKiBUaGUgYWNjb3VudCB3aWxsIGJlIHRlbXBvcmFyeSBzdG9wcGVkIHRvIHBlcmZvcm0gdGhpcyBhY3Rpb24uXG4gICAqIE5vdGUgdGhhdCB0aGlzIGlzIGEgcGFpZCBvcHRpb25cbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gYWNjb3VudCBNZXRhU3RhdHMgQVBJIGlzIGVuYWJsZWRcbiAgICovXG4gIGFzeW5jIGVuYWJsZU1ldGFTdGF0c0FwaSgpIHtcbiAgICBhd2FpdCB0aGlzLl9tZXRhdHJhZGVyQWNjb3VudENsaWVudC5lbmFibGVNZXRhU3RhdHNBcGkodGhpcy5pZCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyB1bnRpbCBBUEkgc2VydmVyIGhhcyBmaW5pc2hlZCBkZXBsb3ltZW50IGFuZCBhY2NvdW50IHJlYWNoZWQgdGhlIERFUExPWUVEIHN0YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0SW5TZWNvbmRzIHdhaXQgdGltZW91dCBpbiBzZWNvbmRzLCBkZWZhdWx0IGlzIDVtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbEluTWlsbGlzZWNvbmRzIGludGVydmFsIGJldHdlZW4gYWNjb3VudCByZWxvYWRzIHdoaWxlIHdhaXRpbmcgZm9yIGEgY2hhbmdlLCBkZWZhdWx0IGlzIDFzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBhY2NvdW50IGlzIGRlcGxveWVkXG4gICAqIEB0aHJvd3Mge1RpbWVvdXRFcnJvcn0gaWYgYWNjb3VudCBoYXZlIG5vdCByZWFjaGVkIHRoZSBERVBMT1lFRCBzdGF0ZSB3aXRoaW4gdGltZW91dCBhbGxvd2VkXG4gICAqL1xuICBhc3luYyB3YWl0RGVwbG95ZWQodGltZW91dEluU2Vjb25kcyA9IDMwMCwgaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9IDEwMDApIHtcbiAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgIHdoaWxlICh0aGlzLnN0YXRlICE9PSAnREVQTE9ZRUQnICYmIChzdGFydFRpbWUgKyB0aW1lb3V0SW5TZWNvbmRzICogMTAwMCkgPiBEYXRlLm5vdygpKSB7XG4gICAgICBhd2FpdCB0aGlzLl9kZWxheShpbnRlcnZhbEluTWlsbGlzZWNvbmRzKTtcbiAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSAnREVQTE9ZRUQnKSB7XG4gICAgICB0aHJvdyBuZXcgVGltZW91dEVycm9yKCdUaW1lZCBvdXQgd2FpdGluZyBmb3IgYWNjb3VudCAnICsgdGhpcy5pZCArICcgdG8gYmUgZGVwbG95ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2FpdHMgdW50aWwgQVBJIHNlcnZlciBoYXMgZmluaXNoZWQgdW5kZXBsb3ltZW50IGFuZCBhY2NvdW50IHJlYWNoZWQgdGhlIFVOREVQTE9ZRUQgc3RhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRJblNlY29uZHMgd2FpdCB0aW1lb3V0IGluIHNlY29uZHMsIGRlZmF1bHQgaXMgNW1cbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsSW5NaWxsaXNlY29uZHMgaW50ZXJ2YWwgYmV0d2VlbiBhY2NvdW50IHJlbG9hZHMgd2hpbGUgd2FpdGluZyBmb3IgYSBjaGFuZ2UsIGRlZmF1bHQgaXMgMXNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGFjY291bnQgaXMgZGVwbG95ZWRcbiAgICogQHRocm93cyB7VGltZW91dEVycm9yfSBpZiBhY2NvdW50IGhhdmUgbm90IHJlYWNoZWQgdGhlIFVOREVQTE9ZRUQgc3RhdGUgd2l0aGluIHRpbWVvdXQgYWxsb3dlZFxuICAgKi9cbiAgYXN5bmMgd2FpdFVuZGVwbG95ZWQodGltZW91dEluU2Vjb25kcyA9IDMwMCwgaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9IDEwMDApIHtcbiAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgIHdoaWxlICh0aGlzLnN0YXRlICE9PSAnVU5ERVBMT1lFRCcgJiYgKHN0YXJ0VGltZSArIHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSA+IERhdGUubm93KCkpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2RlbGF5KGludGVydmFsSW5NaWxsaXNlY29uZHMpO1xuICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09ICdVTkRFUExPWUVEJykge1xuICAgICAgdGhyb3cgbmV3IFRpbWVvdXRFcnJvcignVGltZWQgb3V0IHdhaXRpbmcgZm9yIGFjY291bnQgJyArIHRoaXMuaWQgKyAnIHRvIGJlIHVuZGVwbG95ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2FpdHMgdW50aWwgYWNjb3VudCBoYXMgYmVlbiBkZWxldGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0SW5TZWNvbmRzIHdhaXQgdGltZW91dCBpbiBzZWNvbmRzLCBkZWZhdWx0IGlzIDVtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbEluTWlsbGlzZWNvbmRzIGludGVydmFsIGJldHdlZW4gYWNjb3VudCByZWxvYWRzIHdoaWxlIHdhaXRpbmcgZm9yIGEgY2hhbmdlLCBkZWZhdWx0IGlzIDFzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBhY2NvdW50IGlzIGRlbGV0ZWRcbiAgICogQHRocm93cyB7VGltZW91dEVycm9yfSBpZiBhY2NvdW50IHdhcyBub3QgZGVsZXRlZCB3aXRoaW4gdGltZW91dCBhbGxvd2VkXG4gICAqL1xuICBhc3luYyB3YWl0UmVtb3ZlZCh0aW1lb3V0SW5TZWNvbmRzID0gMzAwLCBpbnRlcnZhbEluTWlsbGlzZWNvbmRzID0gMTAwMCkge1xuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgICAgd2hpbGUgKHN0YXJ0VGltZSArIHRpbWVvdXRJblNlY29uZHMgKiAxMDAwID4gRGF0ZS5ub3coKSkge1xuICAgICAgICBhd2FpdCB0aGlzLl9kZWxheShpbnRlcnZhbEluTWlsbGlzZWNvbmRzKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciBhY2NvdW50ICcgKyB0aGlzLmlkICsgJyB0byBiZSBkZWxldGVkJyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIHVudGlsIEFQSSBzZXJ2ZXIgaGFzIGNvbm5lY3RlZCB0byB0aGUgdGVybWluYWwgYW5kIHRlcm1pbmFsIGhhcyBjb25uZWN0ZWQgdG8gdGhlIGJyb2tlclxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dEluU2Vjb25kcyB3YWl0IHRpbWVvdXQgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyA1bVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyBpbnRlcnZhbCBiZXR3ZWVuIGFjY291bnQgcmVsb2FkcyB3aGlsZSB3YWl0aW5nIGZvciBhIGNoYW5nZSwgZGVmYXVsdCBpcyAxc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gQVBJIHNlcnZlciBpcyBjb25uZWN0ZWQgdG8gdGhlIGJyb2tlclxuICAgKiBAdGhyb3dzIHtUaW1lb3V0RXJyb3J9IGlmIGFjY291bnQgaGF2ZSBub3QgY29ubmVjdGVkIHRvIHRoZSBicm9rZXIgd2l0aGluIHRpbWVvdXQgYWxsb3dlZFxuICAgKi9cbiAgYXN5bmMgd2FpdENvbm5lY3RlZCh0aW1lb3V0SW5TZWNvbmRzID0gMzAwLCBpbnRlcnZhbEluTWlsbGlzZWNvbmRzID0gMTAwMCkge1xuICAgIGNvbnN0IGNoZWNrQ29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIFt0aGlzLmNvbm5lY3Rpb25TdGF0dXNdLmNvbmNhdCh0aGlzLnJlcGxpY2FzLm1hcChyZXBsaWNhID0+IFxuICAgICAgICByZXBsaWNhLmNvbm5lY3Rpb25TdGF0dXMpKS5pbmNsdWRlcygnQ09OTkVDVEVEJyk7XG4gICAgfTtcblxuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgd2hpbGUgKCFjaGVja0Nvbm5lY3RlZCgpICYmIChzdGFydFRpbWUgKyB0aW1lb3V0SW5TZWNvbmRzICogMTAwMCkgPiBEYXRlLm5vdygpKSB7XG4gICAgICBhd2FpdCB0aGlzLl9kZWxheShpbnRlcnZhbEluTWlsbGlzZWNvbmRzKTtcbiAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgfVxuICAgIGlmICghY2hlY2tDb25uZWN0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IFRpbWVvdXRFcnJvcignVGltZWQgb3V0IHdhaXRpbmcgZm9yIGFjY291bnQgJyArIHRoaXMuaWQgKyAnIHRvIGNvbm5lY3QgdG8gdGhlIGJyb2tlcicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byBNZXRhQXBpLiBUaGVyZSBpcyBvbmx5IG9uZSBjb25uZWN0aW9uIHBlciBhY2NvdW50LiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7SGlzdG9yeVN0b3JhZ2V9IGhpc3RvcnlTdG9yYWdlIG9wdGlvbmFsIGhpc3Rvcnkgc3RvcmFnZVxuICAgKiBAcGFyYW0ge0RhdGV9IFtoaXN0b3J5U3RhcnRUaW1lXSBoaXN0b3J5IHN0YXJ0IHRpbWUuIFVzZWQgZm9yIHRlc3RzXG4gICAqIEByZXR1cm4ge1N0cmVhbWluZ01ldGFBcGlDb25uZWN0aW9uSW5zdGFuY2V9IE1ldGFBcGkgY29ubmVjdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0U3RyZWFtaW5nQ29ubmVjdGlvbihoaXN0b3J5U3RvcmFnZSwgaGlzdG9yeVN0YXJ0VGltZSkge1xuICAgIGlmKHRoaXMuX21ldGFBcGlXZWJzb2NrZXRDbGllbnQucmVnaW9uICYmIHRoaXMuX21ldGFBcGlXZWJzb2NrZXRDbGllbnQucmVnaW9uICE9PSB0aGlzLnJlZ2lvbikge1xuICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgYEFjY291bnQgJHt0aGlzLmlkfSBpcyBub3Qgb24gc3BlY2lmaWVkIHJlZ2lvbiAke3RoaXMuX21ldGFBcGlXZWJzb2NrZXRDbGllbnQucmVnaW9ufWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeS5jb25uZWN0U3RyZWFtaW5nKHRoaXMsIGhpc3RvcnlTdG9yYWdlLCBoaXN0b3J5U3RhcnRUaW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byBNZXRhQXBpIHZpYSBSUEMgY29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge1JwY01ldGFBcGlDb25uZWN0aW9uSW5zdGFuY2V9IE1ldGFBcGkgY29ubmVjdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0UlBDQ29ubmVjdGlvbigpIHtcbiAgICBpZih0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50LnJlZ2lvbiAmJiB0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50LnJlZ2lvbiAhPT0gdGhpcy5yZWdpb24pIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgIGBBY2NvdW50ICR7dGhpcy5pZH0gaXMgbm90IG9uIHNwZWNpZmllZCByZWdpb24gJHt0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50LnJlZ2lvbn1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5LmNvbm5lY3RScGModGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0cmFkaW5nIGFjY291bnQuIFxuICAgKiBQbGVhc2UgcmVkZXBsb3kgdGhlIHRyYWRpbmcgYWNjb3VudCBpbiBvcmRlciBmb3IgdXBkYXRlZCBzZXR0aW5ncyB0byB0YWtlIGVmZmVjdFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJBY2NvdW50VXBkYXRlRHRvfSBhY2NvdW50IHVwZGF0ZWQgYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIGFjY291bnQgaXMgdXBkYXRlZFxuICAgKi9cbiAgYXN5bmMgdXBkYXRlKGFjY291bnQpIHtcbiAgICBhd2FpdCB0aGlzLl9tZXRhdHJhZGVyQWNjb3VudENsaWVudC51cGRhdGVBY2NvdW50KHRoaXMuaWQsIGFjY291bnQpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRyYWRpbmcgYWNjb3VudCByZXBsaWNhIGluIGEgcmVnaW9uIGRpZmZlcmVudCBmcm9tIHRyYWRpbmcgYWNjb3VudCByZWdpb24gYW5kIHN0YXJ0cyBhIGNsb3VkIEFQSSBzZXJ2ZXIgZm9yIGl0XG4gICAqIEBwYXJhbSB7TmV3TWV0YVRyYWRlckFjY291bnREdG99IGFjY291bnQgTWV0YVRyYWRlciBhY2NvdW50IGRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZTxNZXRhdHJhZGVyQWNjb3VudFJlcGxpY2E+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGNyZWF0ZWQgTWV0YVRyYWRlciBhY2NvdW50IHJlcGxpY2EgZW50aXR5XG4gICAqL1xuICBhc3luYyBjcmVhdGVSZXBsaWNhKGFjY291bnQpIHtcbiAgICBhd2FpdCB0aGlzLl9tZXRhdHJhZGVyQWNjb3VudENsaWVudC5jcmVhdGVBY2NvdW50UmVwbGljYSh0aGlzLmlkLCBhY2NvdW50KTtcbiAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgIHJldHVybiB0aGlzLl9yZXBsaWNhcy5maW5kKHIgPT4gci5yZWdpb24gPT09IGFjY291bnQucmVnaW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgZXhwZXJ0IGFkdmlzb3Igb2YgY3VycmVudCBhY2NvdW50XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEV4cGVydEFkdmlzb3JbXT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYW4gYXJyYXkgb2YgZXhwZXJ0IGFkdmlzb3IgZW50aXRpZXNcbiAgICovXG4gIGFzeW5jIGdldEV4cGVydEFkdmlzb3JzKCkge1xuICAgIHRoaXMuX2NoZWNrRXhwZXJ0QWR2aXNvckFsbG93ZWQoKTtcbiAgICBsZXQgZXhwZXJ0QWR2aXNvcnMgPSBhd2FpdCB0aGlzLl9leHBlcnRBZHZpc29yQ2xpZW50LmdldEV4cGVydEFkdmlzb3JzKHRoaXMuaWQpO1xuICAgIHJldHVybiBleHBlcnRBZHZpc29ycy5tYXAoZSA9PiBuZXcgRXhwZXJ0QWR2aXNvcihlLCB0aGlzLmlkLCB0aGlzLl9leHBlcnRBZHZpc29yQ2xpZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgZXhwZXJ0IGFkdmlzb3Igb2YgY3VycmVudCBhY2NvdW50IGJ5IGlkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHBlcnRJZCBleHBlcnQgYWR2aXNvciBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFeHBlcnRBZHZpc29yPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBleHBlcnQgYWR2aXNvciBlbnRpdHlcbiAgICovXG4gIGFzeW5jIGdldEV4cGVydEFkdmlzb3IoZXhwZXJ0SWQpIHtcbiAgICB0aGlzLl9jaGVja0V4cGVydEFkdmlzb3JBbGxvd2VkKCk7XG4gICAgbGV0IGV4cGVydEFkdmlzb3IgPSBhd2FpdCB0aGlzLl9leHBlcnRBZHZpc29yQ2xpZW50LmdldEV4cGVydEFkdmlzb3IodGhpcy5pZCwgZXhwZXJ0SWQpO1xuICAgIHJldHVybiBuZXcgRXhwZXJ0QWR2aXNvcihleHBlcnRBZHZpc29yLCB0aGlzLmlkLCB0aGlzLl9leHBlcnRBZHZpc29yQ2xpZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV4cGVydCBhZHZpc29yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlcnRJZCBleHBlcnQgYWR2aXNvciBpZFxuICAgKiBAcGFyYW0ge05ld0V4cGVydEFkdmlzb3JEdG99IGV4cGVydCBleHBlcnQgYWR2aXNvciBkYXRhXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEV4cGVydEFkdmlzb3I+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGV4cGVydCBhZHZpc29yIGVudGl0eVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlRXhwZXJ0QWR2aXNvcihleHBlcnRJZCwgZXhwZXJ0KSB7XG4gICAgdGhpcy5fY2hlY2tFeHBlcnRBZHZpc29yQWxsb3dlZCgpO1xuICAgIGF3YWl0IHRoaXMuX2V4cGVydEFkdmlzb3JDbGllbnQudXBkYXRlRXhwZXJ0QWR2aXNvcih0aGlzLmlkLCBleHBlcnRJZCwgZXhwZXJ0KTtcbiAgICByZXR1cm4gdGhpcy5nZXRFeHBlcnRBZHZpc29yKGV4cGVydElkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcmljYWwgY2FuZGxlcyBmb3IgYSBzcGVjaWZpYyBzeW1ib2wgYW5kIHRpbWVmcmFtZSBmcm9tIHRoZSBNZXRhVHJhZGVyIGFjY291bnQuXG4gICAqIFNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvcmVzdEFwaS9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRIaXN0b3JpY2FsQ2FuZGxlcy9cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgY2FuZGxlcyBmb3IgKGUuZy4gYSBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGltZWZyYW1lIGRlZmluZXMgdGhlIHRpbWVmcmFtZSBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlIGNhbmRsZXMgbXVzdCBiZSBnZW5lcmF0ZWQuIEFsbG93ZWQgdmFsdWVzXG4gICAqIGZvciBNVDUgYXJlIDFtLCAybSwgM20sIDRtLCA1bSwgNm0sIDEwbSwgMTJtLCAxNW0sIDIwbSwgMzBtLCAxaCwgMmgsIDNoLCA0aCwgNmgsIDhoLCAxMmgsIDFkLCAxdywgMW1uLiBBbGxvd2VkXG4gICAqIHZhbHVlcyBmb3IgTVQ0IGFyZSAxbSwgNW0sIDE1bSAzMG0sIDFoLCA0aCwgMWQsIDF3LCAxbW5cbiAgICogQHBhcmFtIHtEYXRlfSBbc3RhcnRUaW1lXSB0aW1lIHRvIHN0YXJ0IGxvYWRpbmcgY2FuZGxlcyBmcm9tLiBOb3RlIHRoYXQgY2FuZGxlcyBhcmUgbG9hZGVkIGluIGJhY2t3YXJkcyBkaXJlY3Rpb24sIHNvXG4gICAqIHRoaXMgc2hvdWxkIGJlIHRoZSBsYXRlc3QgdGltZS4gTGVhdmUgZW1wdHkgdG8gcmVxdWVzdCBsYXRlc3QgY2FuZGxlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gbWF4aW11bSBudW1iZXIgb2YgY2FuZGxlcyB0byByZXRyaWV2ZS4gTXVzdCBiZSBsZXNzIG9yIGVxdWFsIHRvIDEwMDBcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyQ2FuZGxlPj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggaGlzdG9yaWNhbCBjYW5kbGVzIGRvd25sb2FkZWRcbiAgICovXG4gIGdldEhpc3RvcmljYWxDYW5kbGVzKHN5bWJvbCwgdGltZWZyYW1lLCBzdGFydFRpbWUsIGxpbWl0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2hpc3RvcmljYWxNYXJrZXREYXRhQ2xpZW50LmdldEhpc3RvcmljYWxDYW5kbGVzKHRoaXMuaWQsIHRoaXMucmVnaW9uLCBzeW1ib2wsXG4gICAgICB0aW1lZnJhbWUsIHN0YXJ0VGltZSwgbGltaXQpO1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3JpY2FsIHRpY2tzIGZvciBhIHNwZWNpZmljIHN5bWJvbCBmcm9tIHRoZSBNZXRhVHJhZGVyIGFjY291bnQuIFRoaXMgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgTVQ0XG4gICAqIGFjY291bnRzLlxuICAgKiBTZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3Jlc3RBcGkvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkSGlzdG9yaWNhbFRpY2tzL1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSB0aWNrcyBmb3IgKGUuZy4gYSBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcGFyYW0ge0RhdGV9IFtzdGFydFRpbWVdIHRpbWUgdG8gc3RhcnQgbG9hZGluZyB0aWNrcyBmcm9tLiBOb3RlIHRoYXQgY2FuZGxlcyBhcmUgbG9hZGVkIGluIGZvcndhcmQgZGlyZWN0aW9uLCBzb1xuICAgKiB0aGlzIHNob3VsZCBiZSB0aGUgZWFybGllc3QgdGltZS4gTGVhdmUgZW1wdHkgdG8gcmVxdWVzdCBsYXRlc3QgY2FuZGxlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRdIG51bWJlciBvZiB0aWNrcyB0byBza2lwICh5b3UgY2FuIHVzZSBpdCB0byBhdm9pZCByZXF1ZXN0aW5nIHRpY2tzIGZyb20gcHJldmlvdXMgcmVxdWVzdFxuICAgKiB0d2ljZSlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gbWF4aW11bSBudW1iZXIgb2YgdGlja3MgdG8gcmV0cmlldmUuIE11c3QgYmUgbGVzcyBvciBlcXVhbCB0byAxMDAwXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8TWV0YXRyYWRlclRpY2s+Pn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBoaXN0b3JpY2FsIHRpY2tzIGRvd25sb2FkZWRcbiAgICovXG4gIGdldEhpc3RvcmljYWxUaWNrcyhzeW1ib2wsIHN0YXJ0VGltZSwgb2Zmc2V0LCBsaW1pdCkge1xuICAgIHJldHVybiB0aGlzLl9oaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudC5nZXRIaXN0b3JpY2FsVGlja3ModGhpcy5pZCwgdGhpcy5yZWdpb24sIHN5bWJvbCwgc3RhcnRUaW1lLCBvZmZzZXQsIGxpbWl0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdHJhZGluZyBhY2NvdW50IGNvbmZpZ3VyYXRpb24gbGluayBieSBhY2NvdW50IGlkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3R0bEluRGF5c10gTGlmZXRpbWUgb2YgdGhlIGxpbmsgaW4gZGF5cy4gRGVmYXVsdCBpcyA3LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbmZpZ3VyYXRpb25MaW5rPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBjb25maWd1cmF0aW9uIGxpbmtcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUNvbmZpZ3VyYXRpb25MaW5rKHR0bEluRGF5cykge1xuICAgIGNvbnN0IGNvbmZpZ3VyYXRpb25MaW5rID0gYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQuY3JlYXRlQ29uZmlndXJhdGlvbkxpbmsodGhpcy5pZCwgdHRsSW5EYXlzKTtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbkxpbms7XG4gIH1cblxuICBfY2hlY2tFeHBlcnRBZHZpc29yQWxsb3dlZCgpIHtcbiAgICBpZiAodGhpcy52ZXJzaW9uICE9PSA0IHx8IHRoaXMudHlwZSAhPT0gJ2Nsb3VkLWcxJykge1xuICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignQ3VzdG9tIGV4cGVydCBhZHZpc29yIGlzIGF2YWlsYWJsZSBvbmx5IGZvciBNVDQgRzEgYWNjb3VudHMnKTtcbiAgICB9XG4gIH1cblxuICBfZGVsYXkodGltZW91dEluTWlsbGlzZWNvbmRzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgdGltZW91dEluTWlsbGlzZWNvbmRzKSk7XG4gIH1cblxufVxuIl0sIm5hbWVzIjpbIlRpbWVvdXRFcnJvciIsIlJwY01ldGFBcGlDb25uZWN0aW9uSW5zdGFuY2UiLCJTdHJlYW1pbmdNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlIiwiSGlzdG9yeURhdGFiYXNlIiwiRXhwZXJ0QWR2aXNvciIsIlZhbGlkYXRpb25FcnJvciIsIk1ldGF0cmFkZXJBY2NvdW50UmVwbGljYSIsIlJlbGlhYmlsaXR5IiwiU3RhdGUiLCJWZXJzaW9uIiwiQ29ubmVjdGlvblN0YXR1cyIsIkNvcHlGYWN0b3J5Um9sZXMiLCJUeXBlIiwiQWNjb3VudENvbm5lY3Rpb24iLCJDb25maWd1cmF0aW9uTGluayIsIk1ldGF0cmFkZXJBY2NvdW50IiwiaWQiLCJfZGF0YSIsIl9pZCIsInN0YXRlIiwibWFnaWMiLCJjb25uZWN0aW9uU3RhdHVzIiwicXVvdGVTdHJlYW1pbmdJbnRlcnZhbEluU2Vjb25kcyIsInN5bWJvbCIsInJlbGlhYmlsaXR5IiwidGFncyIsIm1ldGFkYXRhIiwicmVzb3VyY2VTbG90cyIsImNvcHlGYWN0b3J5UmVzb3VyY2VTbG90cyIsInJlZ2lvbiIsImNyZWF0ZWRBdCIsIkRhdGUiLCJuYW1lIiwibWFudWFsVHJhZGVzIiwic2xpcHBhZ2UiLCJwcm92aXNpb25pbmdQcm9maWxlSWQiLCJsb2dpbiIsInNlcnZlciIsInR5cGUiLCJ2ZXJzaW9uIiwiaGFzaCIsImJhc2VDdXJyZW5jeSIsImNvcHlGYWN0b3J5Um9sZXMiLCJyaXNrTWFuYWdlbWVudEFwaUVuYWJsZWQiLCJtZXRhc3RhdHNBcGlFbmFibGVkIiwiYWNjZXNzVG9rZW4iLCJjb25uZWN0aW9ucyIsInByaW1hcnlSZXBsaWNhIiwidXNlcklkIiwicHJpbWFyeUFjY291bnRJZCIsImFjY291bnRSZXBsaWNhcyIsInJlcGxpY2FzIiwiX3JlcGxpY2FzIiwiYWNjb3VudFJlZ2lvbnMiLCJyZWdpb25zIiwiZm9yRWFjaCIsInJlcGxpY2EiLCJyZWxvYWQiLCJfbWV0YXRyYWRlckFjY291bnRDbGllbnQiLCJnZXRBY2NvdW50IiwidXBkYXRlZFJlcGxpY2FEYXRhIiwibWFwIiwiY3JlYXRlZFJlcGxpY2FSZWdpb25zIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJ1cGRhdGVkRGF0YSIsImZpbmQiLCJyZXBsaWNhRGF0YSIsInVwZGF0ZURhdGEiLCJwdXNoIiwicmVtb3ZlIiwiX2Nvbm5lY3Rpb25SZWdpc3RyeSIsImRlbGV0ZUFjY291bnQiLCJmaWxlTWFuYWdlciIsImdldEluc3RhbmNlIiwiY2xlYXIiLCJfYXBwbGljYXRpb24iLCJlcnIiLCJkZXBsb3kiLCJkZXBsb3lBY2NvdW50IiwidW5kZXBsb3kiLCJ1bmRlcGxveUFjY291bnQiLCJyZWRlcGxveSIsInJlZGVwbG95QWNjb3VudCIsImluY3JlYXNlUmVsaWFiaWxpdHkiLCJlbmFibGVSaXNrTWFuYWdlbWVudEFwaSIsImVuYWJsZU1ldGFTdGF0c0FwaSIsIndhaXREZXBsb3llZCIsInRpbWVvdXRJblNlY29uZHMiLCJpbnRlcnZhbEluTWlsbGlzZWNvbmRzIiwic3RhcnRUaW1lIiwibm93IiwiX2RlbGF5Iiwid2FpdFVuZGVwbG95ZWQiLCJ3YWl0UmVtb3ZlZCIsIndhaXRDb25uZWN0ZWQiLCJjaGVja0Nvbm5lY3RlZCIsImNvbmNhdCIsImdldFN0cmVhbWluZ0Nvbm5lY3Rpb24iLCJoaXN0b3J5U3RvcmFnZSIsImhpc3RvcnlTdGFydFRpbWUiLCJfbWV0YUFwaVdlYnNvY2tldENsaWVudCIsImNvbm5lY3RTdHJlYW1pbmciLCJnZXRSUENDb25uZWN0aW9uIiwiY29ubmVjdFJwYyIsInVwZGF0ZSIsImFjY291bnQiLCJ1cGRhdGVBY2NvdW50IiwiY3JlYXRlUmVwbGljYSIsImNyZWF0ZUFjY291bnRSZXBsaWNhIiwiciIsImdldEV4cGVydEFkdmlzb3JzIiwiX2NoZWNrRXhwZXJ0QWR2aXNvckFsbG93ZWQiLCJleHBlcnRBZHZpc29ycyIsIl9leHBlcnRBZHZpc29yQ2xpZW50IiwiZSIsImdldEV4cGVydEFkdmlzb3IiLCJleHBlcnRJZCIsImV4cGVydEFkdmlzb3IiLCJjcmVhdGVFeHBlcnRBZHZpc29yIiwiZXhwZXJ0IiwidXBkYXRlRXhwZXJ0QWR2aXNvciIsImdldEhpc3RvcmljYWxDYW5kbGVzIiwidGltZWZyYW1lIiwibGltaXQiLCJfaGlzdG9yaWNhbE1hcmtldERhdGFDbGllbnQiLCJnZXRIaXN0b3JpY2FsVGlja3MiLCJvZmZzZXQiLCJjcmVhdGVDb25maWd1cmF0aW9uTGluayIsInR0bEluRGF5cyIsImNvbmZpZ3VyYXRpb25MaW5rIiwidGltZW91dEluTWlsbGlzZWNvbmRzIiwiUHJvbWlzZSIsInJlcyIsInNldFRpbWVvdXQiLCJjb25zdHJ1Y3RvciIsImRhdGEiLCJtZXRhdHJhZGVyQWNjb3VudENsaWVudCIsIm1ldGFBcGlXZWJzb2NrZXRDbGllbnQiLCJjb25uZWN0aW9uUmVnaXN0cnkiLCJleHBlcnRBZHZpc29yQ2xpZW50IiwiaGlzdG9yaWNhbE1hcmtldERhdGFDbGllbnQiLCJhcHBsaWNhdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLE9BQU9BLGtCQUFrQiwwQkFBMEI7QUFDbkQsT0FBT0Msa0NBQWtDLGlDQUFpQztBQUMxRSxPQUFPQyx3Q0FBd0MsdUNBQXVDO0FBQ3RGLE9BQU9DLHFCQUFxQiwwQkFBMEI7QUFDdEQsT0FBT0MsbUJBQW1CLGtCQUFrQjtBQUM1QyxTQUFRQyxlQUFlLFFBQU8sMEJBQTBCO0FBQ3hELE9BQU9DLDhCQUE4Qiw2QkFBNkI7QUFDbEUsa0NBQWtDO0FBQ2xDLFNBQVFDLFdBQVcsRUFBRUMsS0FBSyxFQUFFQyxPQUFPLEVBQUVDLGdCQUFnQixFQUFFQyxnQkFBZ0IsRUFBRUMsSUFBSSxFQUFFQyxpQkFBaUIsRUFBRUMsaUJBQWlCLFFBQU8sOENBQThDO0FBS3pKLElBQUEsQUFBTUMsb0JBQU4sTUFBTUE7SUF5Qm5COzs7R0FHQyxHQUNELElBQUlDLEtBQUs7UUFDUCxPQUFPLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxHQUFHO0lBQ3ZCO0lBRUE7Ozs7R0FJQyxHQUNELElBQUlDLFFBQVE7UUFDVixPQUFPLElBQUksQ0FBQ0YsS0FBSyxDQUFDRSxLQUFLO0lBQ3pCO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDSCxLQUFLLENBQUNHLEtBQUs7SUFDekI7SUFFQTs7O0dBR0MsR0FDRCxJQUFJQyxtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUNKLEtBQUssQ0FBQ0ksZ0JB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